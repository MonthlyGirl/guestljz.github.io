<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Isabella&#39;s Blog</title>
  
  
  <link href="http://guestljz.com/atom.xml" rel="self"/>
  
  <link href="http://guestljz.com/"/>
  <updated>2021-05-25T08:17:16.355Z</updated>
  <id>http://guestljz.com/</id>
  
  <author>
    <name>Isabella</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HTML、CSS和JavaScript是如何变成页面的</title>
    <link href="http://guestljz.com/2021/05/25/HTM-HTTP-WEB/HTML%E3%80%81CSS%E5%92%8CJavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84/"/>
    <id>http://guestljz.com/2021/05/25/HTM-HTTP-WEB/HTML%E3%80%81CSS%E5%92%8CJavaScript%E6%98%AF%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90%E9%A1%B5%E9%9D%A2%E7%9A%84/</id>
    <published>2021-05-25T08:15:18.000Z</published>
    <updated>2021-05-25T08:17:16.355Z</updated>
    
    
    
    
    <category term="HTTP" scheme="http://guestljz.com/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="http://guestljz.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>神秘又性感的CSS</title>
    <link href="http://guestljz.com/2021/04/29/%E7%A5%9E%E7%A7%98%E5%8F%88%E6%80%A7%E6%84%9F%E7%9A%84CSS/"/>
    <id>http://guestljz.com/2021/04/29/%E7%A5%9E%E7%A7%98%E5%8F%88%E6%80%A7%E6%84%9F%E7%9A%84CSS/</id>
    <published>2021-04-29T03:09:11.000Z</published>
    <updated>2021-04-29T03:42:01.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a><url></h1><p>css数据类型<code>&lt;url&gt;指向一个资源,它的表达形式通过url()函数定义</code></p><blockquote><p>URI和URL? What is URI and what is url?<br><code>URI(统一资源标识符)</code> 与 <code>URL(统一资源定位符) 不同</code>。URL描述资源的位置，URI描述资源的id。URL可以是一个资源的URL（地址）、或URN（统一资源名称）</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;url&gt;&lt;/h1&gt;&lt;p&gt;css数据类型&lt;code&gt;&amp;lt;url&amp;gt;指向一个资源,它的表达形式通过url()函数定义&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
</summary>
      
    
    
    
    
    <category term="CSS" scheme="http://guestljz.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>vue3.0 One Piece</title>
    <link href="http://guestljz.com/2021/04/05/vue3.0/"/>
    <id>http://guestljz.com/2021/04/05/vue3.0/</id>
    <published>2021-04-05T13:59:31.000Z</published>
    <updated>2021-04-13T02:23:33.022Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue3-0的新特性及Vue3-0带来的新变化"><a href="#Vue3-0的新特性及Vue3-0带来的新变化" class="headerlink" title="Vue3.0的新特性及Vue3.0带来的新变化"></a>Vue3.0的新特性及Vue3.0带来的新变化</h1><p>vue3.0 2020年9月发布,命名为One Piece</p><h2 id="Vue3-0-带来的新变化"><a href="#Vue3-0-带来的新变化" class="headerlink" title="Vue3.0 带来的新变化"></a>Vue3.0 带来的新变化</h2><ul><li> 性能的提升 1.3~2x<br><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cYOiEF.png" alt="cYOiEF.png"><br>🧬 如上图可以看出,与vue2.x相比,mount50%提升,内存占用小120%<br>🧸 核心代码+ Composition API:13.5kb,最小11.75kb  可以单独使用<br>🛕 所有的Runtime:22.5kb(vue2是32kb)</li><li>支持TS 新增: Fragment、Teleport、Suspense<h2 id="为什么会有这么大的性能提升"><a href="#为什么会有这么大的性能提升" class="headerlink" title="为什么会有这么大的性能提升?"></a>为什么会有这么大的性能提升?</h2><h3 id="1-Compiler-原理"><a href="#1-Compiler-原理" class="headerlink" title="1/Compiler 原理"></a>1/Compiler 原理</h3><h4 id="🏳️‍🌈静态的节点和静态绑定的class和id不再作更新处理-hoistStatic-gt-SSR优化"><a href="#🏳️‍🌈静态的节点和静态绑定的class和id不再作更新处理-hoistStatic-gt-SSR优化" class="headerlink" title="🏳️‍🌈静态的节点和静态绑定的class和id不再作更新处理(hoistStatic-&gt;SSR优化)"></a>🏳️‍🌈静态的节点和静态绑定的class和id不再作更新处理(hoistStatic-&gt;SSR优化)</h4>vue3中静态的节点和静态绑定的class和id不会做更新处理。 它结合打包标记PatchFlag,进行更新分析，在编译过程中会将template编译成AST语法树。AST是一个抽象的语法树,它会给动态的内容打上标记PatchFlag,在更新或编译的时候会去分析哪些是静态的内容哪些是动态的内容，最后去更新动态的内容。<br>✒️ 使用Vue 3 Template Explorer进行源码对比<br>当我在页面中插入很多个静态span,每个<code>span</code>都是直接创建一个VNode。接着在后面加一个模板语法<code>msg</code>,可以看出，他是创建了一个TextVNode后在跟一个数字，这个数字后面有一个注释<code>/* TEXT */</code>,这个注释的<code>TEXT</code>表示的正是这个模板消息的类型<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cYTbKU.png" alt="cYTbKU.png"><br>✒️ 现在给span中分别绑上静态和动态的class和id,可以看出，当我们绑定静态的id和class时，创建VNode的时候也会把创建的id和class当做静态的数据去处理，而绑定了动态的节点时，就会发现多出来了 <code>/* CLASS, PROPS */</code>，而上面静态的内容都是写死的数据。这样做的目的正是为了区分哪些是静态内容哪些是动态的内容。<strong>在vue Compiler 处理的过程，会着重去注意这个PatchFlag，相当于是给这些节点打上了标识，在更新时只更新相应标识的动态节点</strong><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cYohp6.png" alt="cYohp6.png"><h4 id="🏳️‍🌈-hoistStatic-优化静态节点-输出字符串"><a href="#🏳️‍🌈-hoistStatic-优化静态节点-输出字符串" class="headerlink" title="🏳️‍🌈 hoistStatic,优化静态节点,输出字符串"></a>🏳️‍🌈 hoistStatic,优化静态节点,输出字符串</h4>在右上角有个options,如果在打开了hoistStatic，它会将静态节点抽离出来。如果静态节点有非常多的话他还会去做优化处理，当静态资源达到了一个预值之后，在编译的时候会将这些静态节点都编译为字符串。带来的好处就是提升了js的处理速度。<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cY4Wff.png" alt="cY4Wff.png"><h4 id="🏳️‍🌈事件监听器Cache缓存处理-cacheHandlers"><a href="#🏳️‍🌈事件监听器Cache缓存处理-cacheHandlers" class="headerlink" title="🏳️‍🌈事件监听器Cache缓存处理(cacheHandlers)"></a>🏳️‍🌈事件监听器Cache缓存处理(cacheHandlers)</h4>绑定了一个<code>click</code>事件，它是绑定在上下文中的，<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cYH5cV.png" alt="cYH5cV.png">如果开启了cacheHandlers，<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cYHatA.png" alt="cYHatA.png">这个是时候它相当于是在全局做注册，提升了一个等级后，它的作用是什么？<br>🌰来个栗子,在单个节点和单个事件中可能看不出来，如果我们使用一个自定义组件，在其中绑定一个事件。自定义组件，我们会在某些组件上去引用它，它会挂载在虚拟dom上进行实例化。如果多次引用就会多次进行实例化的时候，原先的做法可能是每次都会创建click方法和指向。开启cacheHandlers之后，这个组件的方法，包括行内的方法，它都会进行cache，这样在组件重复创建的过程中，它不会去重复进行实例化，大大减少了一个内存占用<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cY4D6e.png" alt="cY4D6e.png"><h4 id="🏳️‍🌈-SSR"><a href="#🏳️‍🌈-SSR" class="headerlink" title="🏳️‍🌈 SSR"></a>🏳️‍🌈 SSR</h4><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cY470s.png" alt="cY470s.png">在options中开启SSR,从上可以看出，它也是将多个将态节点编译成一个字符串，使用一个template的方式把模板语法插入进去。主要是借助编辑器的打包工具，将静态和动态的节点抽离出来，以此来提升性能。<h4 id="🏳️‍🌈按需加载"><a href="#🏳️‍🌈按需加载" class="headerlink" title="🏳️‍🌈按需加载"></a>🏳️‍🌈按需加载</h4>现在我们没有任何内容，它只输出了一个<code>render函数</code><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cY4cTI.png" alt="cY4cTI.png">比如现在输入一个input，它引入了createTextVNode，在input上使用<code>v-model</code>,在右侧可以看出，它自动的引入了vModelText，<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cY456g.png" alt="cY456g.png">在加上<code>type=checkbox</code>,可以看出，它引入的vModelCheckbox，<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cY4Tmj.png" alt="cY4Tmj.png">如果type是一个动态的类型，vmodel就会变为vModelDynamic。<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/08/cY4tT1.png" alt="cY4tT1.png">这样做的好处是方便类型检查和动态的加载。</li></ul><h3 id="支持TS-新增了Fragment、Teleport、Suspense三个组件"><a href="#支持TS-新增了Fragment、Teleport、Suspense三个组件" class="headerlink" title="支持TS 新增了Fragment、Teleport、Suspense三个组件"></a>支持TS 新增了Fragment、Teleport、Suspense三个组件</h3><ol><li>Fragment更像是一个特性，它可以使vue不在受根节点的限制，比如在写单组件是，可以在template中随意写入</li><li>Teleport, 它允许我们控制在DOM中哪个父节点下呈现HTML。比如,写一个弹窗组件,并且希望这个弹窗的html放在body下,那么你可以使用它<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;modalOpen = true&quot;</span>&gt;</span> open the modal (with Teleport)<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;modalOpen&quot;</span> <span class="attr">class</span>=<span class="string">&quot;modal&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">                hello world </span></span><br><span class="line"><span class="xml">                <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;modalOpen = false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            modalOpen = <span class="literal">false</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li><li>Suspense 异步组件,支持嵌套加载的异步组件,比如树形组件或者多层级的组织架构,这个时候如果我们希望等这些多层级的架构组件都显示出来后再去加载这个组件,就可以使用Suspense</li></ol><h2 id="按需加载-配合vite-amp-组合-API"><a href="#按需加载-配合vite-amp-组合-API" class="headerlink" title="按需加载(配合vite) &amp; 组合 API"></a>按需加载(配合vite) &amp; 组合 API</h2><p>vite一种构建工具,类似 webpack,目的就是在未来取代webpack</p><h3 id="组合API-Composition-API"><a href="#组合API-Composition-API" class="headerlink" title="组合API (Composition API )"></a>组合API (Composition API )</h3><h4 id="为什么要用Composition-API"><a href="#为什么要用Composition-API" class="headerlink" title="为什么要用Composition API"></a>为什么要用Composition API</h4><ol><li>Vue2中对于复杂逻辑组件,在后期会变的很难维护<br>🌰举个栗子<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>倍数加减<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>倍数:&#123;&#123;multiple&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&#x27;add&#x27;</span>&gt;</span>加一<span class="tag">&lt;/<span class="name">button</span>&gt;</span> </span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&#x27;sub&#x27;</span>&gt;</span>减一<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="attr">count</span>: <span class="number">0</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">computed</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">multiple</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">return</span> <span class="number">2</span>*<span class="built_in">this</span>.count</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="attr">methods</span>:&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">add</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">this</span>.count++</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="built_in">this</span>.count--</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>上面代码只是实现了对<code>count</code>的加减以及倍数的显示,就需要在<code>data、computed、methods</code>中进行操作，<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/09/ctb5fs.png" alt="ctb5fs.png">当我们增加了需求，就会像这样，当我们业务复杂了就会大量出现上面的情况，随着复杂度上升，就会出现这样（下图每个颜色的方块表示一个功能）<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/09/ctbopn.png" alt="ctbopn.png">甚至一个功能还会依赖其他功能，全搅合在一起。 当这个组件的代码超过几百行时，这时增加或修改某个需求，就要在data、methods、computed以及mounted中反复的跳转，这太痛苦了！！<br>如果可以按照逻辑进行分割，变成如下图，是不是就会清晰很多了呢，这样的代码可读性和可维护性都更高<img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/09/ctb760.png" alt="ctb760.png"></li><li>在Vue2中解决这种问题的方法就是使用Mixin，但Mixin也存在缺陷<br>Mixin:官方在Vue3中已经不推崇去使用;它的缺陷:<ol><li>命名冲突,data中和Mixin中变量的命名冲突,Vue2中会优先使用本地data中的变量</li><li>逻辑不清晰,通常我们组件里面看到一个Mixin,什么util.js,code.js,然而并不知道他是干嘛的</li><li>不太容易复用,比如在Mixin里面在封装一个方法,那么这个方法很难在外面进行复用</li><li>slot 插槽,性能较差</li></ol></li><li>TS的支持度,TS是JS的超集，它可以更好地帮助我们做类型检查，使得代码更严谨并且不在出现一些奇奇怪怪的错误。Vue2中的TS支持较差，在Vue3中已经全面支持TS</li></ol><h4 id="Composition-API-中的特性"><a href="#Composition-API-中的特性" class="headerlink" title="Composition API 中的特性"></a>Composition API 中的特性</h4><ol><li>复杂组件逻辑分离</li><li>组件间的逻辑共享</li></ol><h4 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h4><ol><li>reactive<br>接收一个普通对象然后返回该对象的响应式代理<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> state = reactive(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure></li><li>ref<br>接收一个参数值并返回一个响应式的ref对象,它拥有一个指向内部值的单一属性<code>.value</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(count.value)  <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>如果ref在setup()返回的对象中并且在模板中使用,它会自动解套,无需书写<code>.value</code><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;count&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">export</span> <span class="keyword">default</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            <span class="keyword">return</span>&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">                <span class="attr">count</span>:ref(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="javascript"><span class="xml">            &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">        &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>ref作为响应式对象的属性访问或修改时,也会自动解套,如果将<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">    count,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(state.count) <span class="comment">// 0</span></span><br><span class="line">state.count = <span class="number">1</span></span><br><span class="line"><span class="built_in">console</span>.log(count.value)</span><br></pre></td></tr></table></figure>完整栗子<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123; state.count &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; state.count &#125;&#125; *2 =&#123;&#123; double &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;add()&quot;</span>&gt;</span>加一<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&lt;/template&gt;</span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">import</span> &#123; ref, reactive, computed &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="function"><span class="title">setup</span>(<span class="params"></span>)</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// const state = reactive(&#123;</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">//   count: 0,</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// &#125;);</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// 还可以这么写~~~</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> &#123; state, double &#125; = useCounter(<span class="number">1</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> num = ref(<span class="number">2</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">const</span> add = <span class="function">() =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      state.count++;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      num.value += <span class="number">10</span>;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="comment">// const double = computed(() =&gt; num.value * 2);</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml">    <span class="keyword">return</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      state,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      add,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      double,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">      num,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="comment">// 还可以这么写~~~</span></span></span></span><br><span class="line"><span class="javascript"><span class="xml"><span class="keyword">const</span> useCounter = <span class="function">(<span class="params">count</span>) =&gt;</span> &#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">const</span> state = reactive(&#123;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">    count,</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  &#125;);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">const</span> double = computed(<span class="function">() =&gt;</span> state.count * <span class="number">2</span>);</span></span></span><br><span class="line"><span class="javascript"><span class="xml">  <span class="keyword">return</span> &#123; state, double &#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml">&#125;;</span></span></span><br><span class="line"><span class="javascript"><span class="xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li></ol><h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><ol><li>todos<br><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/04/12/cDDiU1.gif" alt="cDDiU1.gif"><br>github地址,觉得不错的话,给个start啦!! <a href="git@github.com:guestljz/Vue3-todos.git">《Vue3.0 todos》</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Vue3-0的新特性及Vue3-0带来的新变化&quot;&gt;&lt;a href=&quot;#Vue3-0的新特性及Vue3-0带来的新变化&quot; class=&quot;headerlink&quot; title=&quot;Vue3.0的新特性及Vue3.0带来的新变化&quot;&gt;&lt;/a&gt;Vue3.0的新特性及Vue3.0</summary>
      
    
    
    
    <category term="Vue" scheme="http://guestljz.com/categories/Vue/"/>
    
    
    <category term="vue3.0 Compiler" scheme="http://guestljz.com/tags/vue3-0-Compiler/"/>
    
  </entry>
  
  <entry>
    <title>仅仅打开了1个页面，为什么会有4个进程？</title>
    <link href="http://guestljz.com/2021/03/29/HTM-HTTP-WEB/%E4%BB%85%E4%BB%85%E6%89%93%E5%BC%80%E4%BA%861%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%894%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F/"/>
    <id>http://guestljz.com/2021/03/29/HTM-HTTP-WEB/%E4%BB%85%E4%BB%85%E6%89%93%E5%BC%80%E4%BA%861%E4%B8%AA%E9%A1%B5%E9%9D%A2%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%894%E4%B8%AA%E8%BF%9B%E7%A8%8B%EF%BC%9F/</id>
    <published>2021-03-29T03:09:11.000Z</published>
    <updated>2021-05-25T08:16:03.132Z</updated>
    
    <content type="html"><![CDATA[<p>在chrome浏览器中，打开一个页面需要启动多少进程？<br>点击chrome浏览器右上角的”选项” 菜单，选择”更多工具”子菜单，点击”任务管理器”，这将打开Chrome的任务管理器的窗口，</p><p>和Windows任务管理器一样，Chrome任务管理器也是用来展示运行中Chrome使用的进程信息。从图中可以看出，Chrome启动了4个进程，你也许会好奇，只是打开了一个页面，为什么需要启动这么多进程呢？</p><p>在此之前，我们需要了解一下进程的概念。</p><h1 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h1><p>在了解并程和线程，先了解一下什么是并行处理</p><h2 id="并行处理"><a href="#并行处理" class="headerlink" title="并行处理"></a>并行处理</h2><p>计算机中的并行处理就是同一时刻处理多个任务，比如我们要计算这三个表达式的值，并显示出结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">B = <span class="number">20</span> / <span class="number">5</span></span><br><span class="line">C = <span class="number">7</span> * <span class="number">8</span></span><br></pre></td></tr></table></figure><p>在编写代码的时候，我们可以把这个过程拆分为四个任务</p><ul><li>任务1 是计算 A = 1 + 2</li><li>任务2 是计算 B = 20 / 5</li><li>任务3 是计算 C = 7 * 8</li><li>任务4 是显示最后的计算结果</li></ul><p>正常情况下程序可以使用<code>单线程</code> 来处理，也就是按照顺序分别执行这四个任务</p><p>如果采用多线程，那么我们只需分<code>两步走</code>： 第一步，使用三个线程同时执行前三个任务；第二步，再执行第4个显示任务</p><p>通过对比分析，你会发现用单线程执行任务需要四步，而使用多线程只需要两步。因此，使用并行处理能大大提升性能。</p><h2 id="线程-VS-进程"><a href="#线程-VS-进程" class="headerlink" title="线程 VS 进程"></a>线程 VS 进程</h2><p> 多线程可以并行处理任务，但是<code>线程是不能单独存在的，它是由进程来启动和管理的</code>，那么什么是进程呢？</p><p> <code>一个进程就是一个程序的运行实例</code>。详细解释就是，启动一个程序的时候，操作系统就会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<code>进程</code>。</p><p>如下对比图：<br><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/05/21/gHtOk8.png" alt="进程和线程对比图"></p><p>从中可以看出，<code>线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。</code></p><p>总的来说，进程和线程之间的关系有以下4个特点。</p><ol><li><p><code>进程中的任意一线程执行出错，都会导致整个进程的崩溃</code><br>我们可以模拟以下场景</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A = <span class="number">1</span> + <span class="number">2</span></span><br><span class="line">B = <span class="number">20</span> / <span class="number">5</span></span><br><span class="line">C = <span class="number">7</span> * <span class="number">8</span></span><br></pre></td></tr></table></figure><p>当我稍微对以上三个表达式做一点修改，在计算B的值的时候，我把表达式的分母改成0，当线程执行到 B = 20 / 0 时，由于分母为0，线程会执行出错，这样会导致整个进程奔溃，那么另外两个线程执行的结果也没有了。</p></li><li><p><code>线程之间共享进程中的数据</code><br>线程之间可以对进程的公共数据进行读写操作，从而进行数据通信，如下图<br><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/05/21/gHtOk8.png" alt="gHtOk8.png"><br>从中可以看出，线程1，线程2，线程3分别把执行结果写入A/B/C中，然后线程2继续从A/B/C 中读取数据，用来显示执行结果。</p></li><li><p><code>当一个进程关闭之后，操作系统会回收进程所占用的内存</code><br>当一个进程退出时，操作系统会回收改进程所申请得所有资源；即使其中任意线程因为操作不当导致内存泄漏，当退出时，这些内存也会被正确回收。</p></li></ol><p>比如之前的IE浏览器，支持很多插件，而这些插件很容易导致内存泄漏，这意味着只要浏览器开着，内存占用就有可能会越来越多，但是当关闭浏览器进程时，这些内存都会被系统回收掉。</p><ol start="4"><li><code>进程之间的内容相互隔离</code><br>进程隔离是为了保存操作系统中进程互不干扰的技术，每个进程只能访问自己占有的数据，也就避免出现进程A写入数据到进程B的情况。正是因为进程只能的数据是严格隔离的，所以一个进程如果奔溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进行间通信的（IPC）的机制了。</li></ol><h1 id="单进程浏览器时代"><a href="#单进程浏览器时代" class="headerlink" title="单进程浏览器时代"></a>单进程浏览器时代</h1><p><code>单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里</code>，这些模块包含了网络、插件、JavaScript运行环境、渲染引擎和页面等。单进程浏览器的架构如下<br><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/05/24/gvQ3ss.png" alt="gvQ3ss.png"><br>如此多的功能模块运行在一个进程里，是导致浏览器<code>不稳定</code>、<code>不安全</code>和<code>不流畅</code>的一个主要原因。出现这些问题的主要原因：</p><h2 id="1、不稳定"><a href="#1、不稳定" class="headerlink" title="1、不稳定"></a>1、不稳定</h2><p>早期浏览器需要借助于<code>插件</code>来实现如Web视频、Web游戏等各种强大的功能，但是插件是最容易出现问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外奔溃会引起整个浏览器的奔溃<br>除了插件之外，<code>渲染引擎模块</code>也是不稳定的 ，通常一些复杂的JavaScript代码有可能引起渲染引擎模块的奔溃。和插件一个渲染引擎的奔溃也会引起浏览器的奔溃。</p><h2 id="2、不流畅"><a href="#2、不流畅" class="headerlink" title="2、不流畅"></a>2、不流畅</h2><p>从上面的“单进程浏览器架构示意图”可以看出，所有页面的渲染模块、JavaScript执行环境以及插件都是运行在同一个线程中的，这就意味这同一时刻只能有一个模块可以执行。<br>比如，写了一个无限循环的脚本</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">freeze</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;freeze&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">freeze()</span><br></pre></td></tr></table></figure><p>如果让这个脚本运行在一个单进程浏览器的页面里，0.0。<br>因为这个脚本是无限循环的，所以当其执行时，它会独占整个线程，这样导致其他运行在该线程中的模块就没有机会执行。因为浏览器中所有的页面都运行在该线程中，所有这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变得卡顿。<br>除了脚本或插件会让单进程浏览器变卡顿外，<code>页面的内存泄露</code> 也是单进程变慢的一个重要原因，通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。</p><h2 id="3、不安全"><a href="#3、不安全" class="headerlink" title="3、不安全"></a>3、不安全</h2><p>这个依然可以从插件和页面脚本两个方面来看<br>插件可以使用c++等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完成操作你的电脑，如果是个恶意插件，那么它就可以释放病毒，窃取你的账号密码，引发安全性的问题。<br>页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些事情，同样也会引发安全问题。</p><h1 id="多进程浏览时代"><a href="#多进程浏览时代" class="headerlink" title="多进程浏览时代"></a>多进程浏览时代</h1><p>现代浏览器的出现就是为了解决此类问题，那么是如何解决的呢？</p><h2 id="早期多进程架构"><a href="#早期多进程架构" class="headerlink" title="早期多进程架构"></a>早期多进程架构</h2><p>如图，2008年chrome发布时的进程架构<br><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/05/25/gzdQln.png" alt="gzdQln.png"><br>从中可以看出，Chrome的页面是在单独的渲染进程中的，同时页面里的插件也是运行在单独的插件进程之中，而进程之间是通过IPC机制进行通信</p><p>那么如何解决<code>不稳定</code>的问题。由于进程是相互隔离的，所有当一个页面或插件奔溃时，影响到的仅仅时当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这就完美地解决了页面或者插件的奔溃会导致整个浏览器奔溃，也就是不稳定的问题</p><p>在看看如何解决<code>不流畅</code>的问题。同样，JavaScript也是运行在渲染进程中的，所以即使JavaScript阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，因为其他页面的脚本时运行在它们自己的渲染进程中的。所以当我们再在chrome中运行上面那个死循环的脚本时，没有响应的仅仅是当前的页面。<br>对于<code>内存泄漏</code>的解决方面就更简单了，因为当关闭一个页面时，整个渲染进程也会被关闭，之后改进程所占用的内存都会被系统回收，这样就轻松解决了浏览器页面的内存泄露问题。</p><p>最后看看如何解决<code>安全问题</code>，采用多进程架构的额外好处是可以使用<code>安全沙箱</code>，你可以把沙箱看成是操作系统给进程上了一把锁，沙箱里面的程序可以运行，但是不能在你的硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。</p><h1 id="目前多进程架构"><a href="#目前多进程架构" class="headerlink" title="目前多进程架构"></a>目前多进程架构</h1><p>不过 Chrome 的发展是滚滚向前的，相较之前，目前的架构又有了很多新的变化。<br><img src= "/img/bgTop.jpg" data-lazy-src="https://z3.ax1x.com/2021/05/25/gz6OOJ.png" alt="gz6OOJ.png"><br>从图中可以看出，最新的Chrome浏览器包括：1个浏览器（Browser）主进程、1个GPU进程、1个网络（NetWork）进程、多个渲染进程和多个插件进程。<br>这几个进程的功能</p><ul><li><code>浏览器进程</code>。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li><li><code>渲染进程</code>。核心任务是将HTML、CSS和JavaScript转换为用户可以与之交互的网页，排版引擎Blink和JavaScript引擎V8都是运行在该进程中，默认情况下，chrome会为每个Tab标签创建一个渲染进程。处于安全考虑，渲染进程都是运行在沙箱模式下。</li><li><code>GPU进程</code>。其实，在Chrome刚开始发布的时候是没有GPU进程的。而GPU的使用初衷是为了实现3D CSS的效果，只是随后网页、Chrome的UI界面都选择了采用GPU来绘制，这使得GPU成为浏览器普遍的需求。最后chrome在其多进程架构上也引入了GPU进程。</li><li><code>网络进程</code>。主要复杂页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li><li><code>插件进程</code>。主要是负责插件的运行，因插件易奔溃，所以需要通过插件进程来隔离，以保证插件进程奔溃不会对浏览器和页面造成影响。</li></ul><p>那么，现在就可以解释：仅仅打开了1个页面，为什么会有4个进程？因为打开1个页面至少需要1个网络进程、1个浏览器进程、1个GPU进程以及1个渲染进程，共4个，如果页面还有插件运行的话，还需要加上1个插件进程。</p><p><strong>虽然多进程模型提升了浏览器的稳定性、流程性、安全性，但同样不可避免地带来了一些问题</strong></p><ul><li><code>更高的资源占用</code>。因为每个进程都会包含公共基础结构的副本（如JavaScript运行环境），这就意味着浏览器会消耗更多的内存资源。</li><li><code>更复杂的体系架构</code>。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li></ul><h1 id="未来面向服务的架构"><a href="#未来面向服务的架构" class="headerlink" title="未来面向服务的架构"></a>未来面向服务的架构</h1><p>为了解决这些我问题，在201年，chrome官方团队使用<code>面向服务的架构</code>（Services Oriented Architecture,简称<code>SOA</code>)的思想设计了新的Chrome架构，也就是说chrome整体架构会朝向现代操作系统所采用的”面向服务的架构”方向发展，原来的各种模块会被重构成独立的服务，每个服务都可以在独立的进程中运行，访问服务必须使用定义号的接口，通过IPC来通信，从而<code>构建一个更内聚、松耦合、易于维护和扩展的系统</code>，更好实现chrome简单、稳定、高速、安全的目的。</p><p><strong>总体来说，Chrome是以一个非常快递的速度在进化，越来越多的业务和应用都逐渐转至浏览器来开发</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在chrome浏览器中，打开一个页面需要启动多少进程？&lt;br&gt;点击chrome浏览器右上角的”选项” 菜单，选择”更多工具”子菜单，点击”任务管理器”，这将打开Chrome的任务管理器的窗口，&lt;/p&gt;
&lt;p&gt;和Windows任务管理器一样，Chrome任务管理器也是用来展示</summary>
      
    
    
    
    <category term="HTTP" scheme="http://guestljz.com/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="http://guestljz.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>HTTP协议的各个版本</title>
    <link href="http://guestljz.com/2021/03/01/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/"/>
    <id>http://guestljz.com/2021/03/01/HTTP%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%90%84%E4%B8%AA%E7%89%88%E6%9C%AC/</id>
    <published>2021-03-01T12:51:53.000Z</published>
    <updated>2021-03-02T07:44:25.031Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTTP-协议"><a href="#HTTP-协议" class="headerlink" title="HTTP 协议"></a>HTTP 协议</h1><h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>HTTP 是超文本传输协议,它定义了客户端和服务器之间交换报文的格式和方式,默认采用80端口,它使用TCP作为传输层协议,保证了数据传输的可靠性</p><p>HTTP 是一个无状态的协议,HTTP 服务器不会保存关于客户端的任务信息</p><p>HTTP 有两种连接模式,一种是持续连接,一种是非持续连接;<br>非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接;持续连接,TCP 连接默认不关闭,可以被多个请求复用;采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间; </p><p>在HTTP1.0 以前使用的非持续的连接,但是可以在请求时,加上Connection: keep-alive 来要求服务器不要关闭 TCP 连接</p><p>在HTTP1.1以后默认采用的是持续的连接;目前对于同一个域,大多数浏览器支持同时建立 6 个持久连接</p><h1 id="HTTP-协议的各个版本"><a href="#HTTP-协议的各个版本" class="headerlink" title="HTTP 协议的各个版本"></a>HTTP 协议的各个版本</h1><p>HTTP 是基于 TCP/IP 协议的应用层协议; 它不涉及数据包传输,主要规定了客户端和服务器之间的通信格式,默认使用80端口</p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP/0.9"></a>HTTP/0.9</h2><p>最早的版本是0.9版本,该版本及其简单,只有一个命令 <code>GET</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / index.html</span><br><span class="line"><span class="comment">// TCP 连接建立后,客户端向服务器请求网页 index.html</span></span><br></pre></td></tr></table></figure><p>协议规定,服务器只能回应 HTML 格式的字符串,不能回应别的格式<br>服务器发送完毕,就关闭 TCP 连接</p><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP/1.0"></a>HTTP/1.0</h2><p>HTTP1.0 版本发布,内容大大增加</p><ol><li>首先,任何格式内容都可以发送; 可以传输文字 / 图像 / 视频 / 二进制 文件 </li><li>除了 <code>GET</code> 命令,还引入了 <code>POST</code> / <code>HEAD</code> 命令,使传输信息变得更丰富</li><li>HTTP 请求和回应格式也发生改变了,每次通信都必须包含头信息,用来描述一些元数据</li><li>新增状态码 / 缓存 / 内容编码 / 字符编码 /等等</li></ol><h3 id="Content-Type-字段"><a href="#Content-Type-字段" class="headerlink" title="Content-Type 字段"></a>Content-Type 字段</h3><p>字符编码,1.0版规定,头信息必须是 ASCII 码,后面的数据可以是任何格式;<br>因此服务器回应的时候,必须告诉客户端,数据是什么格式,这就是 <code>Content-type</code> 字段的作用<br>常见的 <code>Content-type</code> 字段的值</p><ul><li>text/plain</li><li>text/html</li><li>text/css</li><li>image/jpeg<br>…</li></ul><h3 id="Content-Encoding-字符"><a href="#Content-Encoding-字符" class="headerlink" title="Content-Encoding 字符"></a>Content-Encoding 字符</h3><p>由于发送的数据可以是任何格式,因此可以把数据压缩后再发送; <code>Content-Encoding</code> 字段说明数据的压缩方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Encoding: compress</span><br><span class="line">Content-Encoding: deflate</span><br></pre></td></tr></table></figure><p>客户端请求时,用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Accept-Encoding: gizp,deflate</span><br></pre></td></tr></table></figure><h3 id="HTTP-1-0-的缺点"><a href="#HTTP-1-0-的缺点" class="headerlink" title="HTTP/1.0 的缺点"></a>HTTP/1.0 的缺点</h3><p>每次 TCP 连接只能发送一个请求,发送数据完毕,连接就关闭,如果还要请求其他资源,就必须再新建一个连接<br>TCP 连接的新建成本高,所以 HTTP/1.0 版本性能较差<br>为了解决这个问题,有些浏览器在请求时,用了一个非标准的 <code>Connection</code> 字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>这个字符要求服务器不要关闭 TCP 连接,以便其他请求复用,服务器同样回应这个字段</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection:keep-alive</span><br></pre></td></tr></table></figure><p>这样一个可以复用的 TCP 连接就建立了,直到客户端或服务器主动关闭连接,但是,这不是标准字段,不同实现的行为可能不一致,因此不是根本的解决方法</p><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP/1.1"></a>HTTP/1.1</h2><p>HTTP/1.1版本的发布,它进一步完善了 HTTP 协议</p><h3 id="持久连接"><a href="#持久连接" class="headerlink" title="持久连接"></a>持久连接</h3><p>1.1版本的最大变化,就是引入了持久连接,即 TCP 连接默认不关闭,可以被多个请求复用,不用声明 <code>Connection:keep-alive</code><br>客户端和服务器发现对方一段时间没有活动,就可以主动关闭连接;不过,规范的做法是,客户端在最后一个请求时,发送 <code>Connection: close</code>,明确要求服务器关闭 TCP 连接,对于同一个域名,大多数浏览器允许同时建立 6 个持久连接</p><h3 id="管道机制"><a href="#管道机制" class="headerlink" title="管道机制"></a>管道机制</h3><p>1.1版本引入了管道机制,即在同一个 TCP 连接里面,客户端可以同时发送多个请求,这样就进一步改进了 HTTP 协议的效率</p><p>举例来说,客户端需要请求两个资源,在1.1版本以前的做法是,在同一个 TCP 连接里面,先发送 A 请求,然后等待服务器做出回应,收到后再发送B请求,管道机制则是允许浏览器同时发送A请求和B请求,但服务器还是按照顺序,先回应A请求,完成后再回应B请求</p><p>另外增加了 <code>PUT</code> / <code>PATCH</code> / <code>DELETE</code> 等方法</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然1.1版本允许复用 TCP 连接,但是同一个 TCP 连接里面,所有的数据通信是依次进行的,服务器只有处理完一个回应,才会进行下一个回应,要是前一个回应特别慢,后面就会 有许多请排队等着,这称为 <code>队头阻塞</code><br>为了避免这个问题,只有两种方法: 一是减少请求数, 二是同时打开多个持久连接,这就是我们对网站优化时，使用雪碧图、合并脚本的<br>原因。 </p><h2 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h2><p>HTTP/2 是谷歌自行研发的 SPDY 协议,主要解决 HTTP/1.1 效率不高的问题</p><p>HTTP/2 主要有以下新的特性:</p><h3 id="二进制协议"><a href="#二进制协议" class="headerlink" title="二进制协议"></a>二进制协议</h3><p>HTTP/2 是一个二进制协议,在 HTTP/1.1 版本中,报文的头信息必须是文本(ASCII编码),数据体可以是文本,也可以是二进制,HTTP/2 则是一个彻底的二进制协议,头信息和数据体都是二进制的,并且统称为 “ 帧 “ ,可以分为头信息帧和数据帧<br>帧的概念是它实现多路复用的基础</p><h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><p>HTTP/2 实现了多路复用,HTTP/2 仍然复用 TCP 连接,但是一个连接里,客户端和服务器都可以同时发送多个请求或回应,而且不用按照顺序一一发送,这样就避免了 “队头阻塞” 的问题</p><h3 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h3><p>HTTP/2 使用了数据流的概念,因为HTTP/2 的数据包不是按顺序发送的,同一个连接里面连续的数据包,可能属于不同的请求;因此,必须要对数据包做标记,指出它属于哪个请求;HTTP/2 将每个请求或回应的所有数据包,称为一个数据流;<br>每个数据流都有一个独一无二的编号;数据包发送的时候,都必须标记数据流 ID ,用来区分它属于哪个数据流</p><h3 id="头信息压缩"><a href="#头信息压缩" class="headerlink" title="头信息压缩"></a>头信息压缩</h3><p>HTTP/2 实现了头信息压缩,由于 HTTP 1.1 协议不带有状态,每次请求都必须附上所有信息,所以请求的很多字段都是重复的,比如 Cookie 和 User Agent,一模一样的内容,每次请求都必须附带,这会浪费很多带宽,也影响速度</p><p>HTTP/2 对这一点做了优化,引入了头新压缩机制,一方面,头信息使用 gzip 或 compress 压缩后再发送;另一方面,客户端和服务器同时维护一张头信息表,所有字段都会存入这个表,生成一个索引号,以后就不发送同样字段了,只发送索引号,这样就能提供速度了</p><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><p>HTTP/2 允许服务器未经请求,主动向客户端发送资源,这叫做服务器推送,使用服务器推送,提前给客户端提送必要的资源,这样就可以相对减少一些延迟时间,这里需要注意的是 HTTP2 下服务器主动推送的是静态资源和 webSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的</p><h3 id="HTTP-2-协议缺点"><a href="#HTTP-2-协议缺点" class="headerlink" title="HTTP/2 协议缺点"></a>HTTP/2 协议缺点</h3><p>因为 HTTP/2 使用了多路复用,一般来说同一域名下只需要使用一个 TCP 连接,由于多个数据流使用同一个 TCP 连接,遵守同一个同一个流量状态控制和拥塞控制,只要一个数据流遭遇拥塞,剩下的数据流就没法发出去,这样就导致了后面的所有数据都被阻塞, HTTP/2 出现的这个问题是由于其使用 TCP 协议的问题,与它本身的实现没有多大关系</p><h2 id="HTTP-3-协议"><a href="#HTTP-3-协议" class="headerlink" title="HTTP/3 协议"></a>HTTP/3 协议</h2><p>由于 TCP 本身存在的一些限制,Google 就开发了一个基于 UDP 协议的 QUIC 协议,并且使用在了 HTTP/3上,QUIC 协议在 UDP 协议上实现了 多路复用 / 有序交付 / 重传 等等功能</p><h2 id="HTTP-存在的问题"><a href="#HTTP-存在的问题" class="headerlink" title="HTTP 存在的问题"></a>HTTP 存在的问题</h2><ol><li>HTTP 报文使用明文的方式发送,可能被第三方窃听</li><li>HTTP 报文可能被第三方截取后修改通信内容,接收方没有办法发现报文内容的修改</li><li>HTTP 还存在认证的问题,第三方可以冒充他人参与通信</li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><p>HTTPS 指的是超文本传输安全协议,HTTPS 是基于 HTTP 协议的,不过它会使用 TLS/SSL 来对数据加密,使用 TLS/SSL 协议,所有的信息都是加密的,第三方没有办法窃听;并且它提供了一种校验机制,信息一旦被篡改,通信的双方会立刻发现,它还配备了身份证书,防止身边被冒充的情况出现</p><h2 id="TLS-握手实现原理"><a href="#TLS-握手实现原理" class="headerlink" title="TLS 握手实现原理"></a>TLS 握手实现原理</h2><p>TLS 的握手过程主要用到了三个方法来保证传输的安全</p><ol><li><p>首先的对称加密的方法,对称加密的方法是,双方使用同一个密钥对数据进行加密和解密,但对称加密存在的一个问题就是如何保证密钥传输的安全性,因为密钥还是会通过网络传输的,一旦密钥被其他人获取到,那么整个加密过程就毫无作用;这就要用到非对称加密的方法</p></li><li><p>非对称加密的方法是,我们拥有两个密钥,一个是公钥,一个是私钥,公钥是公开的,私钥是保密的,用私钥加密的数据只有对应的公钥才能解密,我们可以将公钥公布出去,任务想和我们通信的客户,都可以使用我们提供的公钥对数据进行加密,然后使用私钥进行解密,这样就能保证数据的安全了,但是非对称加密有一个缺点就是加密的过程很慢,因此如果每次通信都使用非对称加密的方法的话,反而会造成等待时间过长的问题; 因此我们可以使用对称加密和非对称加密结合的方法,因为对称加密方式的缺点就是无法保证密钥的安全传输,因此我们可以以非对称加密方式来对对称加密的密钥进行传输,然后以后通信使用对称加密的方式来加密,这样就解决了两个方法各种存在的问题</p></li><li><p>但是现在的方法也不一定是安全的,因为我们没有办法确定我们得到的公钥就一定是安全的公钥,可能存在一个中间人,截取了对方发给我们的公钥,然后将他自己的公钥发送给我们,当我们使用他的公钥加密后发送的信息,就可以被他用自己的私钥解密,然后伪装我们以同样的方法向对方发送信息,这样我们的信息就被窃取了,然而我们自己还不知道<br>为了解决这样的问题,我们可以使用数字证书的方式,首先我们使用一种 Hash 算法来对我们的公钥和其他信息进行加密生成一个信息摘要,然后让有公信力的认证中心,用它的私钥对消息摘要加密,形成签名,最后将原始的信息和签名结合在一起,称为数字证书,当接收方接收到数字证书的时候,先根据原始信息使用同一的 Hash 算法生成一个摘要,然后使用公证处的公钥来对数字证书中的摘要进行解密,最后将解密的摘要和我们生成的摘要进行对比,就能发现我们得到的信息是否被更改了这个方法最重要的是认证中心的可靠性,一般浏览器里会内置一些顶层的认证中心的证书,相当与我们自动信任了他们,只有这样我们才能保证数据的安全</p></li></ol><h1 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h1><ul><li>HTTPS 协议需要申请证书</li><li>HTTP 和HTTPS 使用端口不一样,前者是80, 后者是443</li><li>HTTP 协议运行在 TCP 之上,所有传输的内容都是明文,HTTPS 运行在 SSL/TLS 之上, SSL/TLS 运行在 TCP 之上,所有传输的内容都是密文传输 </li><li>HTTPS 可以有效的防止运营商劫持</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTTP-协议&quot;&gt;&lt;a href=&quot;#HTTP-协议&quot; class=&quot;headerlink&quot; title=&quot;HTTP 协议&quot;&gt;&lt;/a&gt;HTTP 协议&lt;/h1&gt;&lt;h2 id=&quot;概况&quot;&gt;&lt;a href=&quot;#概况&quot; class=&quot;headerlink&quot; title=&quot;概</summary>
      
    
    
    
    <category term="HTTP" scheme="http://guestljz.com/categories/HTTP/"/>
    
    
    <category term="HTTP HTTPS" scheme="http://guestljz.com/tags/HTTP-HTTPS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript</title>
    <link href="http://guestljz.com/2021/03/01/JavaScript/JavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93~~/"/>
    <id>http://guestljz.com/2021/03/01/JavaScript/JavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93~~/</id>
    <published>2021-03-01T05:04:53.000Z</published>
    <updated>2021-03-02T03:23:23.312Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h1><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ol><li>在 js 中我们是使用构造函数来新建一个对象的,每一个构造函数的内部都有一个 prototype 属性,这个属性是一个对象,这个对象上包含了该构造函数的所有实例共享的属性和方法</li><li>当我们使用构造函数新建了一个对象后,在这个对象的内部包含一个指针 <code>__proto__</code>,这个指针指向该对象所属构造函数的 prototype 属性对应的值, 在ES5 中这个指针被称为 对象 的原型</li><li>一般来说我们是不能够获取到这个值的,但是现在的浏览器都实现了 <strong>proto</strong> 属性,让我们可以访问这个属性,但是最后不要用这个属性, 因为它不是规范中规定的</li><li>ES5 中新增了一个Object.getPrototypeOf()方法,我们可以通过这个方法来获取对象的原型</li></ol><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><ul><li>当我们访问一个对象的属性时,如果这个对象内部不存在这个属性,那么它就会去它的原型对象里找这个属性,这个原型对象又会有自己的原型,于是就这样一直找下去,这也就是原型链的概念.</li><li>原型链的尽头一般来说都是 object.prototype </li></ul><h2 id="原型和原型链的特点"><a href="#原型和原型链的特点" class="headerlink" title="原型和原型链的特点"></a>原型和原型链的特点</h2><ul><li>JavaScript 对象是通过引用来传递的,我们创建的每一个新对象实体中并没有 一份属于自己的原型,当我们修改原型时,与之相关的对象也会继承这一改变</li></ul><h2 id="js-获取原型的方法"><a href="#js-获取原型的方法" class="headerlink" title="js 获取原型的方法"></a>js 获取原型的方法</h2><ul><li>p.__proto__</li><li>p.constructor.prototype</li><li>Object.getPrototypeOf(p)</li></ul><h1 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h1><ol><li>作用域: 当前代码对变量的访问权限(函数作用域,es6 let const 声明的块级作用域)</li><li>作用域链: 内层作用域访问一个变量,首先会在当前作用域的父级找,如果没找到,在往上一层找,直到找到全局,如果还没有找到就宣布放弃,这种一层一层向上的关系,就是作用域链,即以链式的方式访问变量</li></ol><h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><ul><li>垃圾回收机制: 会自动释放内存,就是说一个函数执行完毕,内存中的空间会被释放,再一次调用的时候,函数内部会被重新赋值</li></ul><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><h2 id="闭包的作用"><a href="#闭包的作用" class="headerlink" title="闭包的作用"></a>闭包的作用</h2><ol><li>读取函数内部的变量,让全局访问局部变量</li><li>延长变量的生命周期<h2 id="闭包的使用方式"><a href="#闭包的使用方式" class="headerlink" title="闭包的使用方式"></a>闭包的使用方式</h2></li></ol><ul><li>就是函数内部嵌套着另一个函数,这个函数在外部别调用,所以内存不会被回收,从而延长变量的生命周期</li></ul><h1 id="什么是递归"><a href="#什么是递归" class="headerlink" title="什么是递归"></a>什么是递归</h1><ul><li>递归就是函数自己调用函数自己,递归一定要有结束条件,否则会陷入死循环</li><li>使用场景: 遍历树的结构</li></ul><h1 id="js的异步机制"><a href="#js的异步机制" class="headerlink" title="js的异步机制"></a>js的异步机制</h1><p>详情请看本站文章 <a href="https://guestljz.gitee.io/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"><a href="https://guestljz.gitee.io/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/">《js的异步机制》</a></a></p><h1 id="事件循环机制-Event-Loop"><a href="#事件循环机制-Event-Loop" class="headerlink" title="事件循环机制(Event Loop)"></a>事件循环机制(Event Loop)</h1><p>详情请看本站文章 <a href="https://guestljz.gitee.io/2020/12/29/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-event-loop/"><a href="https://guestljz.gitee.io/2020/12/29/JavaScript/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6-event-loop/">《事件循环机制Event Loop》</a></a></p><h1 id="什么是-Promise-对象-什么是-Promise-A"><a href="#什么是-Promise-对象-什么是-Promise-A" class="headerlink" title="什么是 Promise 对象? 什么是 Promise/A+ ?"></a>什么是 Promise 对象? 什么是 Promise/A+ ?</h1><ol><li>promise对象是异步编程的一种解决方案,最早由社区提出,promise/A+规范是javascript promise的规范,规定了一个promise所必须具有的特性</li><li>Promise 是一个构造函数,它接收一个函数作用参数, 并且返回一个promise实例,一个promise实例有三种状态,分别是pending,resolve,reject,对应着进行中,已完成,已失败,一个实例的状态只能由 pending 转换为 resolve 或由 pending 转换为 reject ,状态一经改变就凝固了,无法再改变,我们可以在异步操作结束后调用这两个函数改变promise的状态,一个状态一经改变可以通过 then 注册回调函数,可以立即得到结果</li></ol><h1 id="ES5-继承和-ES6-继承的区别"><a href="#ES5-继承和-ES6-继承的区别" class="headerlink" title="ES5 继承和 ES6 继承的区别"></a>ES5 继承和 ES6 继承的区别</h1><h2 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h2><ul><li>ES5 的继承实质: 先创建子类,再实例化父类,并将父类的方法添加到子类的this中;可以通过原型或构造函数机制来实现</li><li>ES6 实质: 先创建父类,实例化子类通过调用super方法访问父类后,在通过修改this实现继承,super关键字指代父类的实例,即父类的this对象,在子类构造函数中,如果不调用super方法,子类得不到this对象</li><li>ES6 实现继承是通过关键字 <code>extends</code> <code>super</code> 来实现继承</li></ul><h1 id="new-的时候做了什么"><a href="#new-的时候做了什么" class="headerlink" title="new 的时候做了什么"></a>new 的时候做了什么</h1><ol><li>首先创建了一个新的空对象</li><li>设置原型,将对象的原型设置为函数的 prototype 对象</li><li>让函数的 this 指向这个对象,执行构造函数的代码,为这个新对象添加属性</li><li>判断函数的返回值类型,如果是值类型,返回创建的对象;如果是引用类型,就返回这个引用类型的对象</li></ol><p>详情请看本站文章 <a href="http://localhost:4000/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/"><a href="http://guestljz.gitee.io/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/">《如何实现一个 new》</a></a></p><h1 id="Ajax是什么-如何创建一个Ajax"><a href="#Ajax是什么-如何创建一个Ajax" class="headerlink" title="Ajax是什么? 如何创建一个Ajax?"></a>Ajax是什么? 如何创建一个Ajax?</h1><h2 id="什么是Ajax"><a href="#什么是Ajax" class="headerlink" title="什么是Ajax"></a>什么是Ajax</h2><ul><li>AJAX,异步的 JavaScript 和 XML ,是一种实现 无页面刷新 获取数据的 混合技术 ,简单来说就是JavaScript执行异步请求<h2 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h2></li><li>比如,领导要找张三汇报工作,于是领导就委托秘书帮忙去叫张三,然后领导就继续忙自己的工作,直到秘书告诉领导张三到了,接着张三就开始汇报工作</li><li>AJAX 请求数据的流程 就跟 “领导找张三汇报工作相似” , 其中的核心 就是 <strong>秘书</strong>,<strong>秘书</strong>相当于浏览器的XMLHttpRequest对象,当浏览器发出HTTP请求与接收HTTP响应时,浏览器可以接着做其他的事情,直到收到xhr返回的数据渲染页面</li></ul><h2 id="AJAX-实现流程"><a href="#AJAX-实现流程" class="headerlink" title="AJAX 实现流程"></a>AJAX 实现流程</h2><p>创建一个 ajax 有这样几个步骤</p><p>首先是创建一个 XMLHttpRequest 对象。</p><p>然后在这个对象上使用 open 方法创建一个 http 请求，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</p><p>在发起请求前，我们可以为这个对象添加一些信息和监听函数。比如说我们可以通过 setRequestHeader 方法来为请求添加头信息。我们还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，我们可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候我们可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候我们就可以通过 response 中的数据来对页面进行更新了。</p><p>当对象的属性和监听函数设置完成后，最后我们调用 sent 方法来向服务器发起请求，可以传入参数作为发送的数据体。</p><h2 id="AJAX的状态"><a href="#AJAX的状态" class="headerlink" title="AJAX的状态"></a>AJAX的状态</h2><ul><li>0 表示未初始化,尚未调用open方法</li><li>1 启用open方法,数据发生</li><li>2 表示已调用open方法 接收到响应</li><li>3 表示正在解析</li><li>4 表示已完成</li></ul><p>详情请看本站文章 <a href="http://uestljz.gitee.io/2020/12/17/JavaScript/Ajax/"><a href="http://uestljz.gitee.io/2020/12/17/JavaScript/Ajax/">《Ajax》</a></a></p><h1 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h1><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><ul><li>面向对象,是一种编程开发思想,面向对象编程,它将真实世界各种复杂的关系,抽象为一个个对象,然后进行分工合作,完成对真实世界的模拟</li><li>面向对象的特性: 封装 / 多态 / 继承</li><li>面向对象就是对 <strong>现实世界理解和抽象的方法</strong><br>我对面向对象的理解就是: 面向对象的编程方式就是让每一个类都只做一件事,面向过程会让一个类越来越全能,就像是一个管家一样做了所有的事;而面向对象像是雇佣了一群职员,每个人做一件小事,各司其职,最终合作共赢</li></ul><h1 id="JSON-parse-和JSON-stringify"><a href="#JSON-parse-和JSON-stringify" class="headerlink" title="JSON.parse()和JSON.stringify()"></a>JSON.parse()和JSON.stringify()</h1><p>JSON.parse()把字符串解析成对象<br>JSON.stringify()从对象中解析出字符串</p><h1 id="三种事件模型是什么"><a href="#三种事件模型是什么" class="headerlink" title="三种事件模型是什么?"></a>三种事件模型是什么?</h1><p>详情请看本站文章 <a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"><a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/">《事件模型》</a></a> </p><h1 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h1><p>事件委托本质上是利用了浏览器事件冒泡的机制,因为事件在冒泡过程中会上传到父节点,并且父节点可以通过事件对象获取到目标节点,因此可以把子节点的监听函数定义在父节点上,由父节点的监听函数统一处理多个子元素的事件,这种方式称为事件代理</p><p>使用事件代理我们可以不不必要为每一个子元素都绑定一个监听事件,这样减少了内存上的消耗,并且使用事件代理我们还可以实现事件的动态绑定,比如说新增了一个子节点,我们并不需要单独第为它添加一个监听事件,它所它发生的事件会交给父元素中的监听函数来处理</p><h1 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h1><p>执行环境(即执行上下文中)存在着执行代码的的私有作用域,上层作用域的指向,方法的参数,这个作用域中定义的变量以及这个作用域的this对象等等</p><h1 id="堆内存和栈内存"><a href="#堆内存和栈内存" class="headerlink" title="堆内存和栈内存"></a>堆内存和栈内存</h1><p>基本数据类型: 栈内存 先进后出<br>复杂数据类型: 堆内存 优先队列,复杂数据类型将值报存在堆中,将值对应的指针保存在栈中,通过栈中的指针来获取堆中的值</p><h1 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="headerlink" title="模块化开发怎么做"></a>模块化开发怎么做</h1><p>详情请看本站文章  <a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/"><a href="http://guestljz.gitee.io/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/">《模块化》</a></a></p><h1 id="ES6-中新增特性"><a href="#ES6-中新增特性" class="headerlink" title="ES6 中新增特性"></a>ES6 中新增特性</h1><p><a href="https://guestljz.gitee.io/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/"><a href="https://guestljz.gitee.io/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/">《ES6 中新增特性》</a></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原型和原型链&quot;&gt;&lt;a href=&quot;#原型和原型链&quot; class=&quot;headerlink&quot; title=&quot;原型和原型链&quot;&gt;&lt;/a&gt;原型和原型链&lt;/h1&gt;&lt;h2 id=&quot;原型&quot;&gt;&lt;a href=&quot;#原型&quot; class=&quot;headerlink&quot; title=&quot;原型&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://guestljz.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://guestljz.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>事件模型</title>
    <link href="http://guestljz.com/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/"/>
    <id>http://guestljz.com/2021/03/01/JavaScript/%E4%BA%8B%E4%BB%B6%E6%A8%A1%E5%9E%8B/</id>
    <published>2021-03-01T05:04:53.000Z</published>
    <updated>2021-03-01T05:09:08.811Z</updated>
    
    <content type="html"><![CDATA[<h1 id="三种事件模型是什么"><a href="#三种事件模型是什么" class="headerlink" title="三种事件模型是什么?"></a>三种事件模型是什么?</h1><p>事件时用户操作网页时发生的交互动作或者网页本身的一些操作,现代浏览器一共有三种事件模型</p><h2 id="DOM0-级模型"><a href="#DOM0-级模型" class="headerlink" title="DOM0 级模型"></a>DOM0 级模型</h2><ul><li>第一周事件模型是最早的 DOM0 级模型,这种模型不会传播,所以没有事件流的概念,但是现在有的浏览器支持一冒泡的方式实现,它可以在网页中直接定义监听函数,也可以通过 js 属性来指定监听函数,这种方式是所有浏览器都兼容的</li></ul><h2 id="IE-事件模型"><a href="#IE-事件模型" class="headerlink" title="IE 事件模型"></a>IE 事件模型</h2><ul><li>第二种事件模型 是 IE 事件模型,在该事件模型中,一次事件共有两个过程,事件处理阶段,和事件冒泡阶段;事件处理阶段会首先执行目标元素绑定的监听事件;然后是事件冒泡阶段,冒泡指的是事件从目标元素冒泡到 document,依次检查经过的节点是否绑定了事件监听函数,如果有则执行,这种模型通过 attachEvent 来添加监听函数,可以添加多个监听函数,会按顺序一次执行</li></ul><h2 id="DOM2-级模型"><a href="#DOM2-级模型" class="headerlink" title="DOM2 级模型"></a>DOM2 级模型</h2><ul><li>第三种是 DOM2 级事件模型,在该事件模型中,一次事件共有三个过程,第一个过程是事件捕获阶段;事件捕获指的是事件从 document 一直向下传播到目标元素,依次检查经过的节点是否绑定了事件监听函数,如果有则执行,后面这两个阶段和 IE 事件模型的两个阶段相同,这种事件模型,事件绑定函数式 addEventListener,其中第三个参数可以指定事件是否在捕获阶段执行</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;三种事件模型是什么&quot;&gt;&lt;a href=&quot;#三种事件模型是什么&quot; class=&quot;headerlink&quot; title=&quot;三种事件模型是什么?&quot;&gt;&lt;/a&gt;三种事件模型是什么?&lt;/h1&gt;&lt;p&gt;事件时用户操作网页时发生的交互动作或者网页本身的一些操作,现代浏览器一共有三种事</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://guestljz.com/categories/JavaScript/"/>
    
    
    <category term="DOM0级 DOM2级" scheme="http://guestljz.com/tags/DOM0%E7%BA%A7-DOM2%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>模块化</title>
    <link href="http://guestljz.com/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://guestljz.com/2021/03/01/JavaScript/%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2021-03-01T05:04:53.000Z</published>
    <updated>2021-03-01T05:16:33.504Z</updated>
    
    <content type="html"><![CDATA[<h1 id="模块化开发怎么做"><a href="#模块化开发怎么做" class="headerlink" title="模块化开发怎么做"></a>模块化开发怎么做</h1><p>模块化:一个模块是实现一个特点功能的一组方法,在最开始的时候,js 只实现一些简单的功能,所以并没有模块化的概念,但随着程序越来越复杂,代码的模块化开发变得越来越重要</p><p>由于函数具有独立作用域的特点,最原始的写法是使用函数来作为模块,几个函数作用一个模块,但是这种方法容易造成全局污染,且模块间没有联系</p><p>后来提出了对象的写法,通过将函数作为一个对象的方法来实现,这样解决了直接使用函数作用模块的一些缺点,但是这种办法会暴露所以的模块成员,外部代码可以修改内部属性的值</p><p>也可以使用立即执行函数的写法,通过利用闭包来实现模块私有作用域的建立,同时不会对全局作用域造成污染</p><p>简单来说:模块化就是 把函数作为模块 ,<br>缺陷: 污染全局变量, 模块成员之间没什么关系<br>方法: 面向对象思想 ,并使用立即执行函数 ,实现闭包 避免了变量污染 同时同一模块内的成员也有了关系 在模块外部无法修改我们没有暴露出来的变量、函数 这就是简单的模块</p><h2 id="js-的几种模块规范"><a href="#js-的几种模块规范" class="headerlink" title="js 的几种模块规范"></a>js 的几种模块规范</h2><ol><li><p>CommonJS 方法,它通过 require 来引入模块,通过 module.exports 定义模块的输出接口,这种模块加载方案是 服务端的解决方法,它是以同步的方式来引入模块的,因为在服务DAU文件都存储在本地磁盘,读取非常快,所以以同步的方式加载没有问题但如果是在浏览器端,由于模块加载时使用网络请求,因此使用异步加载的方式更加合适</p></li><li><p>AMD 方法,这种方法采用异步加载的方式来加载模块,模块的加载不影响后面语句的执行,所有依赖这个模块的语句都定义在一个回调函数里,等到加载完成后再执行回调函数 require.js 实现了 AMD 规范</p></li><li><p>CMD 方案,这种方案和 AMD 方案都是为了解决异步模块加载的问题,sea.js实现了 CMD 规范,它和require.js 的区别在于模块定义时对依赖的处理不同对依赖模块的执行时机的处理也不同</p></li><li><p>ES6 提出的方案,使用 import 和 export 的形式来导入导出模块,这种方案和上面三种方案都不同</p></li></ol><h1 id="AMD-和-CMD-规范的区别"><a href="#AMD-和-CMD-规范的区别" class="headerlink" title="AMD 和 CMD 规范的区别"></a>AMD 和 CMD 规范的区别</h1><p>主要区别在两个方面</p><ol><li><p>第一个方面是在模块定义时对依赖的处理不同,AMD 推崇依赖前置,在定义模块的时候就要声明其依赖的模块,而 CMD 推崇就近依赖,只有利用某个模块的时候再去 require</p></li><li><p>第二个方面试依赖模块的执行时机处理不同,首先 AMD 和 CMD 对于模块的加载方式都是异步加载,不过他们在于模块的执行时机,AMD 在依赖模块加载完成后就直接执行依赖模块,依赖模块的执行顺序和我们书写的顺序不一定一致,而 CMD 在依赖模块加载完成后并不执行,只是下载而已,等到所有的依赖模块都加载好后,进入回调函数逻辑,遇到require语句时才执行对应模块</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;模块化开发怎么做&quot;&gt;&lt;a href=&quot;#模块化开发怎么做&quot; class=&quot;headerlink&quot; title=&quot;模块化开发怎么做&quot;&gt;&lt;/a&gt;模块化开发怎么做&lt;/h1&gt;&lt;p&gt;模块化:一个模块是实现一个特点功能的一组方法,在最开始的时候,js 只实现一些简单的功能,所</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://guestljz.com/categories/JavaScript/"/>
    
    
    <category term="模块化" scheme="http://guestljz.com/tags/%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>ES6中新增的特性</title>
    <link href="http://guestljz.com/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/"/>
    <id>http://guestljz.com/2021/02/27/JavaScript/ES6%E4%B8%AD%E6%96%B0%E5%A2%9E%E7%9A%84%E7%89%B9%E6%80%A7/</id>
    <published>2021-02-27T09:09:02.000Z</published>
    <updated>2021-02-27T09:43:17.067Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ES6-中新增特性"><a href="#ES6-中新增特性" class="headerlink" title="ES6 中新增特性"></a>ES6 中新增特性</h1><h1 id="新增块级作用域"><a href="#新增块级作用域" class="headerlink" title="新增块级作用域"></a>新增块级作用域</h1><h2 id="通过let-定义块级作用域"><a href="#通过let-定义块级作用域" class="headerlink" title="通过let 定义块级作用域"></a>通过let 定义块级作用域</h2><ol><li>没有变量提升,变量必须先声明后使用</li><li>通过let 声明的变量不能重名<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// console.log(a)  //报错 必须先定义后使用</span></span><br><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>   <span class="comment">//在全局中定义可以在全局中使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">// let a =  1  // 报错不能重复定义相同的变量名</span></span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">1</span>   <span class="comment">//只能在当前块,当前大括号中使用</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="通过const声明"><a href="#通过const声明" class="headerlink" title="通过const声明"></a>通过const声明</h2><ol><li>const声明变量的同时必须初始化,一旦初始化后这个变量的值就不允许修改</li><li>const声明变量也是一个块级作用域的变量,只能在当前块使用</li><li>const声明的变量也没有变量提升,必须先声明后使用</li><li>const 声明的变量不能重名<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line">a = <span class="number">2</span> <span class="comment">//报错,a不允许修改</span></span><br></pre></td></tr></table></figure></li></ol><h1 id="新增函数特性"><a href="#新增函数特性" class="headerlink" title="新增函数特性"></a>新增函数特性</h1><h2 id="函数可以设置默认参数"><a href="#函数可以设置默认参数" class="headerlink" title="函数可以设置默认参数"></a>函数可以设置默认参数</h2><p>在我们调用函数时,如果设置了默认形参,如果没有给函数传参,那么函数可以使用默认形参</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun2</span>(<span class="params">a=<span class="number">1</span>,b=<span class="number">2</span></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(a,b )  <span class="comment">//输出 a=1,b=2</span></span><br><span class="line">&#125;</span><br><span class="line">fun2(<span class="number">10</span>,<span class="number">20</span>) <span class="comment">//输出 a=10,b=20</span></span><br><span class="line">fun2(<span class="number">10</span>) <span class="comment">//输出 a=10,b=2</span></span><br></pre></td></tr></table></figure><p>同样,在构造函数中也可以使用此方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,sex,age=<span class="number">10</span></span>)</span>&#123;</span><br><span class="line">   <span class="built_in">this</span>.name = name</span><br><span class="line">   <span class="built_in">this</span>.sex =sex</span><br><span class="line">   <span class="built_in">this</span>.age = age</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> guestljz = <span class="keyword">new</span> Person(<span class="string">&quot;guestljz&quot;</span>, <span class="string">&quot;女&quot;</span>)</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;guestljz: &#x27;</span>, guestljz);  <span class="comment">//guestljz: Person &#123;name: &quot;guestljz&quot;, age: 10, sex: &quot;女&quot;&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5中的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun3</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    sum +=i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//箭头函数</span></span><br><span class="line"><span class="keyword">const</span> fun3 = <span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> sum = <span class="number">0</span> </span><br><span class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">    sum +=i</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//箭头函数的几种写法</span></span><br><span class="line"><span class="keyword">const</span> fun4= <span class="function">(<span class="params">参数<span class="number">1</span>,参数<span class="number">2</span>,参数<span class="number">3.</span>..</span>)=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 书写语句</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果箭头函数只有一个形参,可以省略括号不写</span></span><br><span class="line"><span class="keyword">const</span> fun5 = <span class="function"><span class="params">abc</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(abc)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果箭头函数的花括号后面只有一句语句,可以省略花括号不写</span></span><br><span class="line"><span class="keyword">const</span> fun6 = <span class="function"><span class="params">abc</span>=&gt;</span> <span class="built_in">console</span>.log(abc)</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果箭头函数花括号后面只有一句语句,并且需要立即返回一个值,那么可以将花括号改写成 ()</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> fun7 = <span class="function"><span class="params">abc</span> =&gt;</span> ( n=abc )</span><br></pre></td></tr></table></figure><p>使用箭头函数,我们可以使用多种方式书写函数,并且更简洁,更方便<br>但值得注意的是,在箭头函数中,没有this,换句话说,箭头函数中的this是外部作用域中的this</p><h3 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h3><p>关于this指向问题相关 参考  <a href="https://guestljz.gitee.io/2021/02/27/JavaScript/this%E6%8C%87%E5%90%91/">《this指向问题》</a></p><h1 id="展开运算符"><a href="#展开运算符" class="headerlink" title="展开运算符"></a>展开运算符</h1><p>将一个个数据打开成为一个个的状态,通过用它来展开数组或对象,也可以在函数传递参数的时候使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr= [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="built_in">console</span>.log(arr)   <span class="comment">//输出 [1,2,3,4,5]</span></span><br><span class="line"><span class="built_in">console</span>.log(..arr)  <span class="comment">//输出 1,2,3,4,5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将多个数组合并成一个数组</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="keyword">let</span> newArr2 = [...arr2,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>]  </span><br><span class="line"><span class="built_in">console</span>.log(newArr2) <span class="comment">//输出一个新数组  [1,2,3,4,5,6,7]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//给函数传递参数使用</span></span><br><span class="line"><span class="keyword">const</span> fun8()=<span class="function">(<span class="params">a,b,c</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;c: &#x27;</span>, c);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;b: &#x27;</span>, b);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a:&quot;</span>,a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line">fun8(...arr3)</span><br></pre></td></tr></table></figure><h1 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h1><p>快速从对象或者数组中获取成功</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组中的解构赋值</span></span><br><span class="line"><span class="keyword">let</span> [a,b,c] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]  <span class="comment">//a=1,b=2,c=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象中的结果赋值</span></span><br><span class="line"><span class="keyword">let</span> &#123;foo,bar&#125;=&#123;<span class="attr">foo</span>:<span class="string">&#x27;aaa&#x27;</span>,<span class="attr">bar</span>:<span class="string">&#x27;bbb&#x27;</span>&#125;  <span class="comment">//foo = aaa, bar=bbb</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//也可以写成这种形式</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>:<span class="string">&#x27;guestljz&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="string">&#x27;10&#x27;</span>,</span><br><span class="line">  <span class="attr">gender</span>:<span class="string">&#x27;女&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; name,age,gender &#125; = obj</span><br><span class="line"></span><br><span class="line"><span class="comment">//或者这种形式</span></span><br><span class="line"><span class="keyword">let</span> &#123; <span class="attr">name</span>:a&#125; = obj </span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">let</span> a = obj.name</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换变量</span></span><br><span class="line"><span class="keyword">let</span> [n1,n2] = [n2,n1]</span><br></pre></td></tr></table></figure><h1 id="新增字符串方法"><a href="#新增字符串方法" class="headerlink" title="新增字符串方法"></a>新增字符串方法</h1><h2 id="string-includes"><a href="#string-includes" class="headerlink" title="string.includes()"></a>string.includes()</h2><p>  判断字符串是否包含一个指定的值,返回一个布尔值,表示是否找到了参数字符串。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s.includes(d): &#x27;</span>, s.includes(<span class="string">&quot;d&quot;</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p> 还支持第二个参数,从哪个位置开始查找<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s.includes(d): &#x27;</span>, s.includes(<span class="string">&quot;d&quot;</span>,<span class="number">4</span>));  <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s.includes(d): &#x27;</span>, s.includes(<span class="string">&quot;g&quot;</span>,<span class="number">4</span>));  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p><h2 id="string-startsWith"><a href="#string-startsWith" class="headerlink" title="string.startsWith()"></a>string.startsWith()</h2><p>表示参数字符串是否在原字符串的头部,返回一个布尔值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s.startsWith(): &#x27;</span>, s.startsWith(<span class="string">&quot;abc&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>同样也支持第二个参数,表示从哪个位置开始</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s.startsWith(): &#x27;</span>, s.startsWith(<span class="string">&quot;abc&quot;</span>,<span class="number">4</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;abc efg&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s.startsWith(): &#x27;</span>, s.startsWith(<span class="string">&quot;efg&quot;</span>,<span class="number">4</span>)); <span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="string-endsWith"><a href="#string-endsWith" class="headerlink" title="string.endsWith()"></a>string.endsWith()</h2><p> 返回布尔值，表示参数字符串是否在原字符串的尾部</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s.endsWith(): &#x27;</span>, s.endsWith(<span class="string">&quot;g&quot;</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>也支持第二个参数,这个第二参数表示,从第0个到第n个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">&#x27;abcdefg&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s.endsWith(): &#x27;</span>, s.endsWith(<span class="string">&quot;d&quot;</span>,<span class="number">4</span>)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>还有许多,详看 阮一峰的es6教程</p><h1 id="Map-和-Set"><a href="#Map-和-Set" class="headerlink" title="Map 和 Set"></a>Map 和 Set</h1><ul><li>Map 和 Set 是 ES6 新增的两个数据类型</li><li>都是属于内置构造函数</li><li>使用 new 的方式来实例化使用</li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><ul><li><p>Set 是一个构造函数,用来生成 Set 数据结构,它类似于数组,但是成员的值都是唯一的 , 没有重复的,初始化 Set 可以接受一个数组或类数组对象作为参数,也可以创建一个空的 Set:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s)</span><br><span class="line"> <span class="comment">//输出</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Set(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">        size: (...)</span></span><br><span class="line"><span class="comment">        __proto__: Set</span></span><br><span class="line"><span class="comment">        [[Entries]]: Array(0)</span></span><br><span class="line"><span class="comment">        length: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>我们可以在 new 的时候直接向内部添加数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化的时候直接添加数据,要以数组的形式添加</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Set(7) &#123;1, 2, 3, &#123;…&#125;, ƒ, …&#125;</span></span><br><span class="line"><span class="comment">    size: (...)</span></span><br><span class="line"><span class="comment">    __proto__: Set</span></span><br><span class="line"><span class="comment">    [[Entries]]: Array(7)</span></span><br><span class="line"><span class="comment">    0: 1</span></span><br><span class="line"><span class="comment">    1: 2</span></span><br><span class="line"><span class="comment">    2: 3</span></span><br><span class="line"><span class="comment">    3: Object</span></span><br><span class="line"><span class="comment">    4: function () &#123;&#125;</span></span><br><span class="line"><span class="comment">    5: true</span></span><br><span class="line"><span class="comment">    6: &quot;hwllo&quot;</span></span><br><span class="line"><span class="comment">    length: 7</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>看上去是一个类似数组的数据结构,但不是数组,是<strong>Set 数据结构</strong></p></li></ul></li></ul><h3 id="常用的方法和属性"><a href="#常用的方法和属性" class="headerlink" title="常用的方法和属性"></a>常用的方法和属性</h3><ul><li><p><code>size</code> : 用来获取该数据结构中有多少数据的</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s.size)  <span class="comment">//7</span></span><br></pre></td></tr></table></figure><ul><li>看上去是一个和数组数据类型差不多的数据结构,而且也看到的 length 属性</li><li>但是不能使用,想要获取该数据类型中的成员数量,<strong>需要使用 size 属性</strong></li></ul></li><li><p><code>add</code> : 用来向该数据类型中追加数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s.size)  <span class="comment">// 7</span></span><br><span class="line"><span class="comment">// 添加</span></span><br><span class="line">s.add(<span class="number">0</span>)</span><br><span class="line">s.add(&#123;<span class="attr">name</span>:<span class="string">&#x27;guestljz&#x27;</span>&#125;)</span><br><span class="line">s.add(&#123;<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123; <span class="built_in">console</span>.log(<span class="string">&quot;有点饿了&quot;</span>)&#125;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s.size)  <span class="comment">//10</span></span><br></pre></td></tr></table></figure><ul><li>这个方法就是向该数据类型中追加数据使用的</li></ul></li><li><p><code>delete</code> : 用来删除该数据结构中的某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s.size)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">s.delete(&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s.size)  <span class="comment">// 9</span></span><br></pre></td></tr></table></figure></li><li><p><code>clear</code> : 清空数据结构中的所有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s.size)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">s.clear()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s.size) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p><code>has</code> : 查询数据结构中有没有某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s.size)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询</span></span><br><span class="line"><span class="built_in">console</span>.log(s.has(<span class="number">0</span>))  <span class="comment">// false </span></span><br><span class="line"><span class="built_in">console</span>.log(s.has(&#123;&#125;))  <span class="comment">// true</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure></li><li><p><code>forEach</code> : 用来遍历 Set 数据结构的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化数据</span></span><br><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,&#123;&#125;,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,<span class="literal">true</span>,<span class="string">&#x27;hello&#x27;</span>])</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;s&#x27;</span>, s.size)  <span class="comment">// 7</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历数据结构的每一项</span></span><br><span class="line">s.forEach(<span class="function"><span class="params">ietm</span>=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;ietm: &#x27;</span>, ietm);</span><br><span class="line">  <span class="comment">//输出</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  ietm:  1</span></span><br><span class="line"><span class="comment">  ietm:  2</span></span><br><span class="line"><span class="comment">  ietm:  3</span></span><br><span class="line"><span class="comment">  ietm:  &#123;&#125;</span></span><br><span class="line"><span class="comment">  ietm:  ƒ ()&#123;&#125;</span></span><br><span class="line"><span class="comment">  ietm:  true</span></span><br><span class="line"><span class="comment">  ietm:  hello</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>方法介绍差不多了,但是有一个问题出现了,那就是</p></li><li><p>我们的方法添加 / 删除 / 查询 ,没有获取</p></li><li><p>获取 Set 结构里面的数据需要借助一个  <code>...</code> 展开运算符</p></li><li><p>把他里面的东西都放到一个数组里面去,然后再去获取</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="keyword">const</span> a = [...s1]</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a: &#x27;</span>, a)</span><br><span class="line"><span class="comment">// 输出 a: (4) [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>,a[<span class="number">0</span>])  <span class="comment">//1</span></span><br></pre></td></tr></table></figure></li><li><p>又有一个问题出现了,new的时候需要以数组的形式传递</p></li><li><p>然后获取的时候又要转成数组的形式获取</p></li><li><p>那为什么不一开始就定义数组,为什么要弄一个 Set 数据类型?</p></li><li><p>这不得不提到一个 Set 的特点</p></li><li><p><strong>Set 不允许存储重复的数据</strong>  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">s.add(<span class="number">4</span>)  <span class="comment">//此时 size 是4</span></span><br><span class="line">s.add(<span class="number">1</span>)  <span class="comment">//此时 size 是4</span></span><br><span class="line">s.add(<span class="number">2</span>)  <span class="comment">//此时 size 是4</span></span><br><span class="line">s.add(<span class="number">3</span>)  <span class="comment">//此时 size 是4</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><ul><li><p>Map 是一个构造函数,用来生成 Map 数据结构,它类似于对象,也是键值对的集合,但是”键”可以是非字符串,初始化 Map 需要一个二维数组,或者直接初始化一个空的 Map:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="built_in">console</span>.log(m)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Map(0) &#123;&#125;</span></span><br><span class="line"><span class="comment">    size: (...)</span></span><br><span class="line"><span class="comment">    __proto__: Map</span></span><br><span class="line"><span class="comment">    [[Entries]]: Array(0)</span></span><br><span class="line"><span class="comment">    length: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ul><li><p>在对象中不管存储什么, key 一定是一个字符串类型,对象是一个键值对 的集合 key : value</p></li><li><p>但是在 Map 里面,key 可以任意数据类型</p></li><li><p>Map 也可以叫做 (值 = 值) 的数据类型</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"> <span class="comment">//   初始化的时候就给一些值</span></span><br><span class="line"> <span class="comment">//   传递的参数需要是一个数组</span></span><br><span class="line"> <span class="comment">//   数组需要是一个 二维数组</span></span><br><span class="line"> <span class="comment">//   二维数组里面的每一个小数组接受两个数据</span></span><br><span class="line"> <span class="comment">//   这个两个数据可以是任意数据类型</span></span><br><span class="line"> <span class="comment">//   这个两个数据第一个就是 key，第二个就是 value</span></span><br><span class="line"> <span class="keyword">const</span> m1 = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Jack&#x27;</span>], [&#123; <span class="attr">a</span>: <span class="number">100</span> &#125;, <span class="number">18</span>]])</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="常用方法和属性"><a href="#常用方法和属性" class="headerlink" title="常用方法和属性"></a>常用方法和属性</h3><ul><li><p><code>size</code> ： t用来获取该数据类型中数据的个数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[&#123;&#125;, &#123;&#125;], [<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;], [<span class="literal">true</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(m.size) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></li><li><p><code>delete</code> : 用来删除该数据集合中的某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>([[&#123;&#125;, &#123;&#125;], [<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;], [<span class="literal">true</span>, <span class="number">1</span>]])</span><br><span class="line">  m.delete(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.size) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li><li><p><code>set</code> : 用来向该数据集合中添加数据使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line"><span class="built_in">console</span>.log(m.size) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></li><li><p><code>get</code> : 用来获取该数据集合中的某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">m.set(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.set(<span class="literal">true</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(m.get(<span class="literal">true</span>)) <span class="comment">// function () &#123;&#125;</span></span><br></pre></td></tr></table></figure></li><li><p><code>clear</code> : 清除数据集合中的所有数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">m.set(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.set(<span class="literal">true</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line">m.clear()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.size) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure></li><li><p><code>has</code> ： 用来判断数据集合中是否存在某一个数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line">m.set(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.set(<span class="literal">true</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m.has(<span class="literal">true</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li><li><p>forEach ：遍历 MAP 数据集合中的成员</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">m.set(&#123; <span class="attr">name</span>: <span class="string">&#x27;Jack&#x27;</span> &#125;, &#123; <span class="attr">age</span>: <span class="number">18</span> &#125;)</span><br><span class="line">m.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul><h1 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h1><ul><li><p>ES5 中我们表示字符串的时候使用 <code>&#39;&#39;</code> 或者 <code>&quot;&quot;</code></p></li><li><p>在 ES6 中，我们还有一个东西可以表示字符串，就是 **``**（反引号）</p></li><li><p>区别是使用 **``**（反引号）我们可以在字符串里面使用 <code>$&#123;变量名&#125;</code> 拼接变量</p></li><li><p>使用 单引号再字符串中不能直接换行,使用反引号可以直接换行</p></li></ul><h1 id="Symbol类型"><a href="#Symbol类型" class="headerlink" title="Symbol类型"></a>Symbol类型</h1><ul><li><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。</p></li><li><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。</p></li><li><p>在创建symbol类型数据时的参数只是作为标识使用，直接使用 Symbol() 也是可以的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> s = <span class="built_in">Symbol</span>(<span class="string">&#x27;xm&#x27;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log( s );</span><br><span class="line"> <span class="built_in">console</span>.log( <span class="keyword">typeof</span> s );</span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。</span></span><br><span class="line"> <span class="keyword">var</span> xm = <span class="built_in">Symbol</span>();</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     [xm] : <span class="string">&quot;小明&quot;</span> <span class="comment">//对象的属性是Symbol类型</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//Symbol类型的属性 取值是 必须 obj[xm] 不能用obj.xm</span></span><br><span class="line"> <span class="built_in">console</span>.log( obj[xm] );</span><br><span class="line"></span><br><span class="line"> <span class="keyword">var</span> s4 = <span class="built_in">Symbol</span>();</span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;xm&#x27;</span>,</span><br><span class="line">     [s4]: <span class="string">&#x27;xh&#x27;</span>,</span><br><span class="line">     [<span class="built_in">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]: <span class="number">18</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="built_in">console</span>.log(obj); <span class="comment">// &#123;name: &quot;xm&quot;, Symbol(): &quot;xh&quot;, Symbol(age): 18&#125;</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj.name); <span class="comment">// xm</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj[s4]); <span class="comment">// xh 访问对象的Symbol属性的值</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj[<span class="built_in">Symbol</span>(<span class="string">&#x27;age&#x27;</span>)]); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//修改symbol类型的属性</span></span><br><span class="line"> obj[xm] = <span class="string">&quot;web前端&quot;</span>;</span><br><span class="line"> <span class="built_in">console</span>.log( obj[xm] );</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"> <span class="comment">//对象的Symbol属性不会被遍历出来（可以用来保护对象的某个属性）</span></span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">     <span class="string">&quot;sname&quot;</span>:<span class="string">&quot;小明&quot;</span>,</span><br><span class="line">     <span class="string">&quot;skill&quot;</span> : <span class="string">&quot;web&quot;</span></span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">var</span> age = <span class="built_in">Symbol</span>();</span><br><span class="line"> obj[age] = <span class="number">18</span>;</span><br><span class="line"> <span class="built_in">console</span>.log( obj );</span><br><span class="line"> <span class="keyword">for</span>( <span class="keyword">var</span> key <span class="keyword">in</span> obj )&#123;</span><br><span class="line">     <span class="built_in">console</span>.log(key + <span class="string">&quot; -&gt; &quot;</span> + obj[key] );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>Object.getOwnPropertySymbols 方法会返回当前对象的所有 Symbol 属性，返回数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">let</span> id = <span class="built_in">Symbol</span>(<span class="string">&quot;id&quot;</span>);</span><br><span class="line"> <span class="keyword">let</span> obj = &#123;</span><br><span class="line">     [id]: <span class="string">&#x27;007&#x27;</span>,</span><br><span class="line">     [<span class="built_in">Symbol</span>(<span class="string">&#x27;name&#x27;</span>)]: <span class="string">&#x27;xiaocuo&#x27;</span></span><br><span class="line"> &#125;;</span><br><span class="line"> <span class="keyword">let</span> arr = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"> <span class="built_in">console</span>.log(arr); <span class="comment">//[Symbol(id),Symbol(name)]</span></span><br><span class="line"> <span class="built_in">console</span>.log(obj[arr[<span class="number">0</span>]]);  <span class="comment">//&#x27;007&#x27;  访问对象的Symbol属性的值</span></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 虽然这样保证了Symbol的唯一性，但我们不排除希望能够多次使用同一个symbol值的情况。</span></span><br><span class="line"> <span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"> <span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&#x27;name&#x27;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log( s1 === s2 ); <span class="comment">// false</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 官方提供了全局注册并登记的方法：</span></span><br><span class="line"> <span class="keyword">let</span> name1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到未创建后新建 </span></span><br><span class="line"> <span class="keyword">let</span> name2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;name&#x27;</span>); <span class="comment">//检测到已创建后返回 </span></span><br><span class="line"> <span class="built_in">console</span>.log(name1 === name2); <span class="comment">// true</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 通过symbol对象获取到参数值：</span></span><br><span class="line"> <span class="keyword">let</span> name1 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;张三&#x27;</span>);</span><br><span class="line"> <span class="keyword">let</span> name2 = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;丽丽&#x27;</span>);</span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(name1));  <span class="comment">// &#x27;张三&#x27;</span></span><br><span class="line"> <span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(name2)); <span class="comment">// &#x27;丽丽&#x27;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;ES6-中新增特性&quot;&gt;&lt;a href=&quot;#ES6-中新增特性&quot; class=&quot;headerlink&quot; title=&quot;ES6 中新增特性&quot;&gt;&lt;/a&gt;ES6 中新增特性&lt;/h1&gt;&lt;h1 id=&quot;新增块级作用域&quot;&gt;&lt;a href=&quot;#新增块级作用域&quot; class=&quot;he</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://guestljz.com/categories/JavaScript/"/>
    
    
    <category term="ES6" scheme="http://guestljz.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>this指向</title>
    <link href="http://guestljz.com/2021/02/27/JavaScript/this%E6%8C%87%E5%90%91/"/>
    <id>http://guestljz.com/2021/02/27/JavaScript/this%E6%8C%87%E5%90%91/</id>
    <published>2021-02-27T06:31:25.000Z</published>
    <updated>2021-02-27T09:19:31.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="this指向问题"><a href="#this指向问题" class="headerlink" title="this指向问题"></a>this指向问题</h1><p>this是一个使用在作用域里面的关键字<br>this的指向只跟函数调用有关</p><ul><li>在全局中使用this,this === window ,this指向全局,但很少在全局中使用</li><li>一个函数的this指向只和函数的调用有关(箭头函数除外),不管怎么定义,在哪定义,分以下几种情况<ol><li>函数在全局中调用,那么this就指向全局</li><li>对象调用,this就指向当前对象</li><li>事件处理函数,this指向事件源</li><li>定时器处理函数,this指向window</li></ol></li></ul><h1 id="强行改变this指向"><a href="#强行改变this指向" class="headerlink" title="强行改变this指向"></a>强行改变this指向</h1><p>在ES5的函数中使用this,因为当不同的函数在不同的作用域中调用,this的指向也就不一样,通常需要强行改变this指向,改变this指向可以通过以下三种方法 </p><h2 id="1-call"><a href="#1-call" class="headerlink" title="1. call()"></a>1. call()</h2><ul><li>直接在函数名后面使用</li><li>正常调用方式: fn(),obj.fn()</li><li>强行改变this指向方式: fn.call(),obj.call()</li><li>参数(两个参数及以上)<br>call(参数1,参数2…)<br>第一个参数表示: this要指向哪里,不传或传null,表示this指向window<br>第二个参数开始:传递给函数的参数,供函数内部使用</li><li>作用: 改变函数内部的this指向</li><li>特点: 会直接调用函数,函数会被立即执行</li></ul><h2 id="2-apply"><a href="#2-apply" class="headerlink" title="2. apply()"></a>2. apply()</h2><p>   使用方式与call一样</p><ul><li>参数:<br>apply(参数1,参数2)<br>第一个参数表示:改变this指向的对象,不传或传null,表示this指向window<br>第二个参数:是一个数组或伪数组,数组中存放传递给函数 的参数,供函数内部使用</li><li>作用:改变函数内部的this指向,函数会被立即执行</li><li>特点: 改变函数传参的方式</li></ul><h2 id="3-bind"><a href="#3-bind" class="headerlink" title="3. bind()"></a>3. bind()</h2><p>  使用方式和前两个一样,参数与call一样</p><ul><li>作用: 改变函数内部this指向,函数不会被立即执行</li><li>特点:<br>不会直接调用函数,返回一个新函数,这个新函数中的this指向已经改变,在我们需要时调用执行即可<br>bind改变过后,this指向不会再改变了</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;this指向问题&quot;&gt;&lt;a href=&quot;#this指向问题&quot; class=&quot;headerlink&quot; title=&quot;this指向问题&quot;&gt;&lt;/a&gt;this指向问题&lt;/h1&gt;&lt;p&gt;this是一个使用在作用域里面的关键字&lt;br&gt;this的指向只跟函数调用有关&lt;/p&gt;
&lt;ul</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://guestljz.com/categories/JavaScript/"/>
    
    
    <category term="this" scheme="http://guestljz.com/tags/this/"/>
    
  </entry>
  
  <entry>
    <title>React总结</title>
    <link href="http://guestljz.com/2021/02/22/React/React%E6%80%BB%E7%BB%93/"/>
    <id>http://guestljz.com/2021/02/22/React/React%E6%80%BB%E7%BB%93/</id>
    <published>2021-02-22T13:49:17.000Z</published>
    <updated>2021-02-24T05:33:02.936Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React中的key的作用"><a href="#React中的key的作用" class="headerlink" title="React中的key的作用"></a>React中的key的作用</h1><blockquote><p>key可以帮助React跟踪循环列表中的虚拟DOM,以此来了解哪些元素是已更改 / 添加 / 删除 的</p><p>react利用key来识别组件,它是一种唯一标识,相同的key React会认为是同一个组件,后续相同key对应组件都不会被创建</p><p>有了key属性后,就可以与组件建立相应的关系,react根据key来决定组件是销毁还是更新</p><p>如果key相同,组件的属性有所变化,那么react只更新组件对应的属性,没有变化则不更新</p><p>key值不同,那么react先销毁该组件,然后在重新创建组件</p></blockquote><h1 id="React的生命周期"><a href="#React的生命周期" class="headerlink" title="React的生命周期"></a>React的生命周期</h1><h3 id="1-挂载阶段-有3个常用的生命周期"><a href="#1-挂载阶段-有3个常用的生命周期" class="headerlink" title="1.挂载阶段,有3个常用的生命周期"></a>1.挂载阶段,有3个常用的生命周期</h3><ol><li>construtor()<br>实例被初始化时会调用这个函数,是所有生命周期中第一个执行的函数,可以在这里定义声明式变量</li><li>componentDidMount()<br>实例初始化完成,这个生命周期只执行一次,再次更新视图时不执行,可以在这里修改state,调接口,建立长连接</li><li>render()<br>所有生命周期中必须要有的生命周期,且一定要有返回值,并且返回的是一个jsx对象,它在挂载阶段和更新阶段都会zhixing</li></ol><h3 id="2-更新阶段-有2个常用的生命周期"><a href="#2-更新阶段-有2个常用的生命周期" class="headerlink" title="2.更新阶段,有2个常用的生命周期"></a>2.更新阶段,有2个常用的生命周期</h3><ol><li>componentUpdate()<br>它表示视图已更新完成,每次更新State中的数据,都会执行componentUpdate()和render()</li><li>shouldComponentUpdate()<br>它的作用是在类组件中提升性能,抽离出不参与视图渲染的数据,让它们不参与diff运算<br>这个生命周期必要要有一个返回值,且返回值是一个布尔值,返回false时不更新</li></ol><h3 id="3-销毁阶段-只有一个生命周期"><a href="#3-销毁阶段-只有一个生命周期" class="headerlink" title="3.销毁阶段,只有一个生命周期"></a>3.销毁阶段,只有一个生命周期</h3><ol><li><p>componentWillUnMount()<br>它表示组件将要被销毁,一般在这里清除定时器 / 缓存 / 长连接 等</p><h1 id="调用setState之后发生了什么"><a href="#调用setState之后发生了什么" class="headerlink" title="调用setState之后发生了什么"></a>调用setState之后发生了什么</h1></li></ol><ul><li>在代码中调用setState之后,React会将传入的参数对象与当前的状态进行合并,然后触发调和过程</li><li>经过调和过程,React会以相对高效的方式根据新的状态构建React虚拟DOM树,并且开始准备重新渲染UI界面</li><li>React在得到虚拟DOM树后,会先比较新得到的树和老树的差异,然后根据diff运算进行界面的最小化渲染</li><li>在diff运算算法中,React能够精确的知道哪些元素发生了变化,以及应该如何变化,这就保证了按需更新,而不是全部更新</li></ul><h1 id="多次触发setState-那么render会执行几次"><a href="#多次触发setState-那么render会执行几次" class="headerlink" title="多次触发setState,那么render会执行几次"></a>多次触发setState,那么render会执行几次</h1><ul><li>多次的setState最终会合并成一次render,因为setState不能立即修改state的值,而是将它放到一个任务队列中,最终多个setState会被合并,一次性更新页面</li><li><strong>传入对象会被合并</strong></li><li><strong>传入函数不会被合并,函数无法合并</strong></li></ul><h1 id="setState什么时候同步-什么时候异步"><a href="#setState什么时候同步-什么时候异步" class="headerlink" title="setState什么时候同步?什么时候异步?"></a>setState什么时候同步?什么时候异步?</h1><ol><li>如果是由React引发的事件处理(如:通过onClinck触发的事件处理),此时<code>setState</code>是异步的,它不会同步更新<code>this.state</code>,并且多个<code>setState</code>在执行过程中会被合并;除此之外,<code>setState</code>是同步的,而这里的”除此之外”是指绕过react,使用原生DOM事件(如addEventListener)调用<code>setState</code>,还有通过 <code>setTimeOut</code> / <code>setInterval</code> 执行<code>setState()</code>,此时<code>setState</code>是同步的</li></ol><h1 id="为什么要调用setState而不是直接修改state"><a href="#为什么要调用setState而不是直接修改state" class="headerlink" title="为什么要调用setState而不是直接修改state"></a>为什么要调用setState而不是直接修改state</h1><ul><li>如果你尝试直接state,那么react将接收不到state被修改的信息,即它无法知道它需要重新渲染组件;因此需要调用 <code>setState()</code>方法,这样react才会更新UI组件</li></ul><h1 id="this-setState-之后React都做了哪些工作"><a href="#this-setState-之后React都做了哪些工作" class="headerlink" title="this.setState 之后React都做了哪些工作"></a>this.setState 之后React都做了哪些工作</h1><ul><li>shouldcomponentUpdate()</li><li>render()</li><li>componentDidUpdate()</li></ul><h1 id="虚拟DOM是如何工作的"><a href="#虚拟DOM是如何工作的" class="headerlink" title="虚拟DOM是如何工作的"></a>虚拟DOM是如何工作的</h1><ul><li>当数据发生变化时,比如setSTate时,会引起组件的重新渲染,整个UI都会以虚拟DOM的形式重新渲染</li><li>然后React就会收集差异进行diff运算,diff运算会找出虚拟DOM中的脏节点</li><li>最后将差异队列中的差异渲染到真实的DOM上</li></ul><h1 id="为什么要使用虚拟DOM"><a href="#为什么要使用虚拟DOM" class="headerlink" title="为什么要使用虚拟DOM"></a>为什么要使用虚拟DOM</h1><ul><li>频繁的DOM操作,会导致页面的重绘和回流,出于性能考虑,我们要减少页面的重绘和回流<h2 id="什么是重绘"><a href="#什么是重绘" class="headerlink" title="什么是重绘"></a>什么是重绘</h2></li><li>当DOM树中一些元素需要更新属性,而这些属性只是影响元素的外观,风格,不影响元素的布局时,称为重绘,比如:修改background-color,这就叫重绘<h2 id="什么是回流"><a href="#什么是回流" class="headerlink" title="什么是回流"></a>什么是回流</h2></li><li>当DOM树中,因为元素的尺寸,规模,布局时需要重新构建时,便称为回流,一个DOM树中,至少经历一次回流,就是页面初始化渲染时<h2 id="重绘和回流的区别"><a href="#重绘和回流的区别" class="headerlink" title="重绘和回流的区别"></a>重绘和回流的区别</h2></li><li>回流一定会引起重绘,重绘不一定会引起回流,比如当整个页面只有颜色发生改变时就只会发生重绘而不会引起回流</li><li>如果是元素的布局或几何属性发生改变时,就会引起回流,比如改变div的大小,加padding,margin等</li></ul><h1 id="虚拟DOM为什么会提高性能"><a href="#虚拟DOM为什么会提高性能" class="headerlink" title="虚拟DOM为什么会提高性能"></a>虚拟DOM为什么会提高性能</h1><ul><li>虚拟DOM相当于在js和真实的DOM中间加了一层缓存,利用DOM的diff避免过多的操作真实DOM,从而提升性能</li><li>用javascript对象表示DOM树</li><li>然后用这个对象树构建一个真正的DOM树,插到文档当中,当状态变更的时候,重新构造一颗新的对象树</li><li>之后进行diff运算,进行新老两树相比较,记录两颗树的差异从而将差异渲染到真实的DOM树中</li></ul><h1 id="diff运算原理"><a href="#diff运算原理" class="headerlink" title="diff运算原理"></a>diff运算原理</h1><ul><li>在传统做法中,diff运算是一个深度递归的过程,则就是将整颗树进行循环遍历进行比较,从而找出不同,效率低下,算法复杂度达到O(n^3)</li><li>所以react在diff运算上基于以下三个策略上做了很大的提升</li></ul><ol><li>web UI中DOM节点跨层级的移动操作特别少,可以忽略不计</li><li>拥有同类的两个组件将会生成相似的树形结构,拥有不同类的两个组件将会生成不同的树形结构</li><li>对于同一层级的一组子节点,它们可以通过唯一 id(即key) 进行区分</li></ol><p>基于以上三个策略,react分别对应的 tree diff,component diff ,element diff 进行算法优化</p><ul><li><p>tree diff<br>基于策略一,React 对树进行分层比较,两棵树只会对同一层次的节点进行比较<br>那么如果出现了跨层级的移动和操作,那么将为以当前这个脏节点为根节点,根节点下的整个树将会被重新创建,这是一种影响React性能的操作,因此官方建议不要进行DOM节点跨层级的操作</p></li><li><p>component diff<br>基于策略二,对于同类型组件,则按照原策略继续比较 Virtrual DOM树,对于同类型的组件,有可能其虚拟DOM 没有任何变化,如何能够准确知道这点,那么就可以节省大量的diff运算时间;因此,react允许用户通过shouldComponentUpdate()来判断该组件是否需要进行diff算法分析<br>如果不是,则将该组件判断为 dirty component ,然后替换整个组件下的所有子节点</p></li><li><p>element diff<br>策略三,脏节点在同一类型组件,根据策略三,同一层级的节点,它们通过key进行区分,当我们遍历一遍待渲染的节点,就能确定要添加 / 删除 / 更新的节点 , 然后修改组件</p></li></ul><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><ul><li>状态管理的作用: 1.组件间的数据共享,数据变化组件间的页面也变化,2.做缓存<h2 id="Redux-的三个3原则"><a href="#Redux-的三个3原则" class="headerlink" title="Redux 的三个3原则"></a>Redux 的三个3原则</h2></li><li>三个api: createStore() / combineReducers() / applyMidleWare()</li><li>三个特点: Store 是只读的 / 单向数据流 / 修改state只能通过纯函数 reducer 来修改</li><li>三个概念: store/ reducer / action</li></ul><h2 id="Redux-的工作流程"><a href="#Redux-的工作流程" class="headerlink" title="Redux 的工作流程"></a>Redux 的工作流程</h2><blockquote><p>当用户在View 触发dispatch,dispatch会生成一个action()方法,将它发送给Store;Store接收到action方法后,会调用reducer函数,Store会传2两个参数给reducer,一个是初始化的state,另一个是收到的action,以此来修改State,当State变化时,View也发生变化,由此可以知道reducer是一个纯函数,它会返回一个新的state,即修改后的state</p></blockquote><h2 id="在Redux中调接口"><a href="#在Redux中调接口" class="headerlink" title="在Redux中调接口"></a>在Redux中调接口</h2><blockquote><p>redux只支持dispatch同步的action,并且要求action只能是一个plain object(普通对象)<br>当react组件中dispatch(fetch)触发调接口,此时,action不是一个plain object,是一个函数,而store中不支持接收函数,所以需要使用中间件 react-thunk</p></blockquote><p>完成一次异步的dispatch需要两次派发<br>第一次派发一个空的action<br>第二次才会将action派发到store中<br>第一次dispatch的action会被thunk这个中间件接收,thunk首先会判断,此时这个action是不是一个函数,如果不是,原封不动的将这个action转发到store中,如果此时这个action是一个函数,那么thunk会执行函数内部的代码,执行第二次派发 直接执行这个函数,执行完毕再将这个函数返回的结果转发到store中</p><h2 id="Redux中的中间件"><a href="#Redux中的中间件" class="headerlink" title="Redux中的中间件"></a>Redux中的中间件</h2><ul><li>thunk,dispatch一个函数</li><li>saga,以generator方式书写Redux</li><li>promise,也是解决异步,允许payload是一个promise对象</li></ul><h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><h3 id="1-什么是Hook"><a href="#1-什么是Hook" class="headerlink" title="1.什么是Hook?"></a>1.什么是Hook?</h3><blockquote><p>Hook是React新增的特性,它可以在你不使用类组件的情况下使用State和其他的react特性</p></blockquote><h4 id="1-1-常用的Hook"><a href="#1-1-常用的Hook" class="headerlink" title="1-1.常用的Hook"></a>1-1.常用的Hook</h4><p>如: </p><ol><li><p>useState  </p><blockquote><p>关于useState的用法是: 需要传入一个参数作为状态的初始值,当函数执行后会返回两个值,一个是当前状态的属性,一个是修改状态的方法</p></blockquote></li><li><p>useEffect</p><blockquote><p>副作用, 通常在副作用中进行ajax请求,事件的绑定和解绑,设置定时器和清除器等;<br>useEffect有两个参数<br>第一个参数是一个回调函数,这个回调函数相当于 React生命周期中 componentDidMount() 这个钩子函数(只是相当于这个生命周期,实际上并不是生命周期),在这个回调函数中,可以进行ajax请求,设置定时器,绑定事件等等 ; 这个回调函数的返回值是一个函数,这个返回值,它相当于是React生命周期中componentWillUnmount() 这个钩子函数,我们可以在这里清除定时器,清除缓存,对事件进行解绑等<br>useEffect的第二个参数是依赖项数组,如果数组中的依赖发送变化,那么该副作用就会重新执行,如果不设置第二个参数,那么当该组件每渲染一次,副作用就会执行一次;如果设置为空数组,那么该副作用只会在组件初次渲染时执行一次<br>在副作用中,不仅可以进行ajax请求,还可以通过调用的本地的State来进行页面更新</p></blockquote></li><li><p>useContext</p><blockquote><p>上下文</p></blockquote></li><li><p>useRef</p><blockquote><p>获取DOM节点,进行DOM操作</p></blockquote></li><li><p>useMemo</p><blockquote><p>useMemo,创建一个依赖函数,当其中一个依赖项更改时,useMemo重新计算机记忆的值,而不需要在每个组件渲染时进行diff运算<br>目的: 避免重复进行复杂耗时的代码计算,所以将计算的结果存起来. 只有在需要计算时使用<br>传入两个参数: 一个回调函数,一个依赖项数组<br>useMemo 的作用<br>useMemo其实创建了一种数据缓存机制,比如登录页面需要向后台发送含用户名&amp;密码的ajax请求,获取用户登录信息,useMemo可以设置成只有当有用户密码改变后才向后台重新发送ajax,而在组件重新渲染时使用缓存的用户信息<br>useMemo与useEffect区别<br>useMemo 与 useEffect 作用类似,都会在依赖值改变时重新执行,但useMemo有一个缓存的返回值, 因此在组件渲染生命周期中,很自然地会把useMemo放到渲染DOM前执行</p></blockquote></li></ol><p>  <strong>useMemo =&gt; 渲染DOM =&gt; useEffect</strong><br>  当我们遇到复杂的计算可以使用useMemo<br>6. useCallback</p><blockquote><p>与useMemo传入的参数是一样的,都是在其依赖项发送变化后才执行的,都是返回缓存的值,区别在于useMemo返回的是函数运行的结果,useCallback返回的是函数<br>  <strong>大部分时不用,可以在搭配shouldComponentUpdate()或有多个useEffect时使用</strong></p></blockquote><h1 id="React中context"><a href="#React中context" class="headerlink" title="React中context"></a>React中context</h1><ul><li>作用: 用于React组件树中传递数据,避免使用复杂的链式的props数据传递</li><li>上下文机制: 它的数据只能单向传输,从父组件向内部组件传递</li></ul><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><h2 id="怎么理组合"><a href="#怎么理组合" class="headerlink" title="怎么理组合"></a>怎么理组合</h2><ol><li>组合在React中,是一种非常强大的组件复用的设计模式, react中组件复用的思想用的是组合的思想</li><li>建立的语法基础:props可传递任何数据类型,包括jsx对象</li></ol><h1 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h1><ul><li>将组件需要共用的数据,提升到相同的父组件的props中,子组件通过props使用这些数据,以达到数据共用的效果</li></ul><h1 id="高阶组件"><a href="#高阶组件" class="headerlink" title="高阶组件"></a>高阶组件</h1><h2 id="什么是高阶组件"><a href="#什么是高阶组件" class="headerlink" title="什么是高阶组件"></a>什么是高阶组件</h2><ul><li>高阶组件实际上就是一个纯函数,即唯一的输入得到唯一的输出,所以高阶函数也叫高阶组件<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2></li><li>是一种组件复用的技巧,用于修饰UI组件<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2></li><li>基础react组合的特性</li></ul><h1 id="React数据类型检查"><a href="#React数据类型检查" class="headerlink" title="React数据类型检查"></a>React数据类型检查</h1><ul><li>使用第三库props_types,对自定义属性执行类型检查</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React中的key的作用&quot;&gt;&lt;a href=&quot;#React中的key的作用&quot; class=&quot;headerlink&quot; title=&quot;React中的key的作用&quot;&gt;&lt;/a&gt;React中的key的作用&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;key可以帮助React跟</summary>
      
    
    
    
    <category term="React" scheme="http://guestljz.com/categories/React/"/>
    
    
    <category term="React" scheme="http://guestljz.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Hook</title>
    <link href="http://guestljz.com/2021/02/22/React/Hook/"/>
    <id>http://guestljz.com/2021/02/22/React/Hook/</id>
    <published>2021-02-22T05:39:14.000Z</published>
    <updated>2021-02-24T04:05:24.766Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hook"><a href="#Hook" class="headerlink" title="Hook"></a>Hook</h1><h3 id="1-什么是Hook"><a href="#1-什么是Hook" class="headerlink" title="1.什么是Hook?"></a>1.什么是Hook?</h3><blockquote><p>Hook是React新增的特性,它可以在你不使用类组件的情况下使用State和其他的react特性</p></blockquote><h4 id="1-1-常用的Hook"><a href="#1-1-常用的Hook" class="headerlink" title="1-1.常用的Hook"></a>1-1.常用的Hook</h4><p>如: </p><ol><li><p>useState  </p><blockquote><p>关于useState的用法是: 需要传入一个参数作为状态的初始值,当函数执行后会返回两个值,一个是当前状态的属性,一个是修改状态的方法</p></blockquote></li><li><p>useEffect</p><blockquote><p>副作用, 通常在副作用中进行ajax请求,事件的绑定和解绑,设置定时器和清除器等;<br>useEffect有两个参数<br>第一个参数是一个回调函数,这个回调函数相当于 React生命周期中 componentDidMount() 这个钩子函数(只是相当于这个生命周期,实际上并不是生命周期),在这个回调函数中,可以进行ajax请求,设置定时器,绑定事件等等 ; 这个回调函数的返回值是一个函数,这个返回值,它相当于是React生命周期中componentWillUnmount() 这个钩子函数,我们可以在这里清除定时器,清除缓存,对事件进行解绑等<br>useEffect的第二个参数是依赖项数组,如果数组中的依赖发送变化,那么该副作用就会重新执行,如果不设置第二个参数,那么当该组件每渲染一次,副作用就会执行一次;如果设置为空数组,那么该副作用只会在组件初次渲染时执行一次<br>在副作用中,不仅可以进行ajax请求,还可以通过调用的本地的State来进行页面更新</p></blockquote></li><li><p>useContext</p><blockquote><p>上下文</p></blockquote></li><li><p>useRef</p><blockquote><p>获取DOM节点,进行DOM操作</p></blockquote></li><li><p>useMemo</p><blockquote><p>useMemo,创建一个依赖函数,当其中一个依赖项更改时,useMemo重新计算机记忆的值,而不需要在每个组件渲染时进行diff运算<br>目的: 避免重复进行复杂耗时的代码计算,所以将计算的结果存起来. 只有在需要计算时使用<br>传入两个参数: 一个回调函数,一个依赖项数组<br>useMemo 的作用<br>useMemo其实创建了一种数据缓存机制,比如登录页面需要向后台发送含用户名&amp;密码的ajax请求,获取用户登录信息,useMemo可以设置成只有当有用户密码改变后才向后台重新发送ajax,而在组件重新渲染时使用缓存的用户信息<br>useMemo与useEffect区别<br>useMemo 与 useEffect 作用类似,都会在依赖值改变时重新执行,但useMemo有一个缓存的返回值, 因此在组件渲染生命周期中,很自然地会把useMemo放到渲染DOM前执行</p></blockquote></li></ol><p>  <strong>useMemo =&gt; 渲染DOM =&gt; useEffect</strong><br>  当我们遇到复杂的计算可以使用useMemo<br>6. useCallback</p><blockquote><p>与useMemo传入的参数是一样的,都是在其依赖项发送变化后才执行的,都是返回缓存的值,区别在于useMemo返回的是函数运行的结果,useCallback返回的是函数<br>  <strong>大部分时不用,可以在搭配shouldComponentUpdate()或有多个useEffect时使用</strong>  </p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Hook&quot;&gt;&lt;a href=&quot;#Hook&quot; class=&quot;headerlink&quot; title=&quot;Hook&quot;&gt;&lt;/a&gt;Hook&lt;/h1&gt;&lt;h3 id=&quot;1-什么是Hook&quot;&gt;&lt;a href=&quot;#1-什么是Hook&quot; class=&quot;headerlink&quot; title=</summary>
      
    
    
    
    <category term="React" scheme="http://guestljz.com/categories/React/"/>
    
    
    <category term="Hook" scheme="http://guestljz.com/tags/Hook/"/>
    
  </entry>
  
  <entry>
    <title>Redux</title>
    <link href="http://guestljz.com/2021/02/02/React/Redux/"/>
    <id>http://guestljz.com/2021/02/02/React/Redux/</id>
    <published>2021-02-02T11:47:06.000Z</published>
    <updated>2021-02-23T12:30:53.891Z</updated>
    
    <content type="html"><![CDATA[<font size=3><blockquote><font size=3 color=#5285C8> 什么时候用到 Redux ? <br/></font></blockquote><blockquote><p><font color=black>有人曾说过 :</font> <font size=4 color=#E7776C>“如果你不知道是否需要 Redux，那就是不需要它 “</font>  <br/></p></blockquote><blockquote><p><font color=black> 接着又有人补充 :</font> <font color=#E7776C>“只有遇到 React 实在解决不了的问题，你才需要 Redux 。” </font></p></blockquote><h1 id="Redux的流程"><a href="#Redux的流程" class="headerlink" title="Redux的流程"></a>Redux的流程</h1><p>先看图<br><a href="https://imgchr.com/i/yuJCxH"><img src= "/img/bgTop.jpg" data-lazy-src="https://s3.ax1x.com/2021/02/02/yuJCxH.gif" alt="yuJCxH.gif"></a></p><h1 id="Redux-的三个3原则"><a href="#Redux-的三个3原则" class="headerlink" title="Redux 的三个3原则"></a>Redux 的三个3原则</h1><font size=4><p>1️⃣ 三个api: createStore()  / combineReducers() / applyMiddleware() </p><p>2️⃣ 三个特点: store是只读的  /  单向数据流  /  修改store只能通过纯函数reducer来修改</p><p>3️⃣ 三个概念: store / reducer / action </font></p><h1 id="Redux-的基本概念和API"><a href="#Redux-的基本概念和API" class="headerlink" title="Redux 的基本概念和API"></a>Redux 的基本概念和API</h1><h3 id="1-Store-就是保存数据的地方-可以把它看成是一个容器-整个应用只能有一个store"><a href="#1-Store-就是保存数据的地方-可以把它看成是一个容器-整个应用只能有一个store" class="headerlink" title="1. Store 就是保存数据的地方,可以把它看成是一个容器,整个应用只能有一个store"></a>1. Store 就是保存数据的地方,可以把它看成是一个容器,整个应用只能有一个store</h3><p>  Redux提供 createStore() 这个函数,用来生成store()</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125;  <span class="keyword">from</span> <span class="string">&#x27;redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> store = createStore(fn)</span><br></pre></td></tr></table></figure><h3 id="2-State-如果把Store看成是一个仓库-那么State-就是仓库的中货物-每个货物对应一个State"><a href="#2-State-如果把Store看成是一个仓库-那么State-就是仓库的中货物-每个货物对应一个State" class="headerlink" title="2. State,如果把Store看成是一个仓库,那么State 就是仓库的中货物, 每个货物对应一个State;"></a>2. State,如果把Store看成是一个仓库,那么State 就是仓库的中货物, 每个货物对应一个State;</h3><p>  在Redux中,Store 对象包含着所有的数据,如果想要拿到期中的数据,就要对Store生成快照,此时生成的数据就叫State<br>  Redux规定,一个State对应一个View,只要State相同,View就相同</p><font color=#0000>🥖 State 的变化,会导致 页面 即View 的变化,但用户接触不到State,只能接触到View;所以State的变化必须是View导致的;而Action就是View 发出的通知,表示State应该要发生变化了</font><h3 id="3-Action"><a href="#3-Action" class="headerlink" title="3. Action"></a>3. Action</h3><p>  State的变化,会导致页面 即View的变化,但是用户接触不到State,只能接触到View;所以State 的变化必须是View 导致; 而Action就是 View 发出的通过,表示State 应该要发生变化了</p><p>  Action 是一个对象 ,其中type是必填属性</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> payload=&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">  <span class="attr">payload</span>:<span class="string">&#x27;hello word&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-dispatch"><a href="#4-dispatch" class="headerlink" title="4. dispatch()"></a>4. dispatch()</h3><p>  dispath()是View发出Action的唯一方法,当用户在 View 触发 dispatch, dispatch会生成一个Action()方法, 将它发送给Store<br>  使用dispatch的方式有很多,可以使用高阶组件或hooks</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用hooks</span></span><br><span class="line"><span class="keyword">import</span> &#123; useDispatch &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"><span class="keyword">const</span> dispatch = useDispatch()</span><br><span class="line"><span class="comment">//dispatch一个action方法</span></span><br><span class="line">dispatch(&#123;</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,</span><br><span class="line">  <span class="attr">payloa</span>:<span class="string">&quot;hello word&quot;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="5-Reducer"><a href="#5-Reducer" class="headerlink" title="5. Reducer"></a>5. Reducer</h3><p>  Store 收到Action 后,必须给出一个新的State,这样View才会发生变化,这种State的计算过程就叫Reducer;<br>  也就是说必须根据 View 的变化 修改Store,而Store是只读,只能使用纯函数,即只能在Reducer中修改–&gt; 得出 Reducer 是一个纯函数<br>  纯函数表示:只要是同样的输入，必定得到同样的输出。</p> <font color=#0000> 🥖 实际上 在 createStore()函数中, 接收另一函数作为参数,这个函数就是Reducer 函数<p> 🥖 Reducer 函数接收两个参数,一个是初始State,另一个是action<br> </font></p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">initState=&#123;&#125;,ation</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//这里面根据action传来的参数修改store中的数据</span></span><br><span class="line">  <span class="comment">//Store 是只读的,并且是单向的,所以不能被直接修改</span></span><br><span class="line">  <span class="comment">//先进行一层深拷贝</span></span><br><span class="line">  <span class="keyword">let</span> newStore = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>,stringify(store))</span><br><span class="line">  <span class="keyword">switch</span>(action.type)&#123;</span><br><span class="line">    <span class="keyword">case</span> type:</span><br><span class="line">      <span class="comment">//做一些操作,修改State</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="在组件中使用-Redux"><a href="#在组件中使用-Redux" class="headerlink" title="在组件中使用 Redux"></a>在组件中使用 Redux</h1><h2 id="使用上下文Provider-将store传到App中"><a href="#使用上下文Provider-将store传到App中" class="headerlink" title="使用上下文Provider 将store传到App中"></a>使用上下文Provider 将store传到App中</h2><h2 id="在组件中-可以使用高阶组件或hooks将react和redux连接起来"><a href="#在组件中-可以使用高阶组件或hooks将react和redux连接起来" class="headerlink" title="在组件中,可以使用高阶组件或hooks将react和redux连接起来"></a>在组件中,可以使用高阶组件或hooks将react和redux连接起来</h2><ul><li>使用高阶组件 </li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//引入</span></span><br><span class="line"><span class="keyword">import</span> &#123;connect &#125;  <span class="keyword">from</span>  <span class="string">&#x27;react-redux&#x27;</span></span><br></pre></td></tr></table></figure><font color=#00000>    其中,connect(fn1,fn2)(UI)组件  中间接收两个函数作为参数,然后修饰到UI组件中      fn1 是 mapStateToProps 将state 中的数据 映射到组件的props中 ,组件通过props 获取store中的数据  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToProps</span>(<span class="params">store</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//接收一个store参数</span></span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">msg</span>:store.msg</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  fn2 是 mapDispatchToProps  将View 中修改的数据 dispatch 到reducer 的action中 ,action通过dispatch中的数据修改state </p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToProps</span>(<span class="params">dispatch</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span>&#123;</span><br><span class="line">    <span class="attr">changeMsg</span>:<span class="function">()=&gt;</span>dispatch(&#123;<span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,<span class="attr">payload</span>:<span class="string">&#x27;hello Word&#x27;</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用hook</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useSelector,useDispath &#125; <span class="keyword">from</span> <span class="string">&#x27;react-redux&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> msg = useSelector(store.msg)</span><br><span class="line"><span class="keyword">const</span> dispatch = useDispatch()</span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  dipatch(&#123;<span class="attr">type</span>:<span class="string">&#x27;add&#x27;</span>,<span class="attr">payload</span>:<span class="string">&#x27;hello word&#x27;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Redux-中调接口"><a href="#Redux-中调接口" class="headerlink" title="Redux 中调接口"></a>Redux 中调接口</h1><p><strong>redux只支持 dispatch 同步的action,并且要求action只能使用plain object</strong></p><blockquote><p>当react组件中dispatch(fetch)触发调接口,此时fetch并不是一个plain object,是一个函数,redux的store收到一个plain object的action时就会报错</p></blockquote><p><strong>所以异步的action需要使用一个第三方库 redux-thunk</strong><br>creactStore 使用一个中间件, thunk<br>creactStore(reducer,applyMiddleware(thunk))</p><p>🦴 完成一次异步的action,需要两次派发<br>🦴 第一次派发一个空的action,<br>🦴 第二次才将action派发到store中</p><p>🟣 此时,第一次dispatch的action会被thunk这个中间件接收,thunk中首先会判断,此时这个action是不是一个函数,如果不是,原封不动的将这个action转发store中; 如果 此是这个action是一个函数,那么thunk会执行函数内部的代码,执行第二次派发,直接执行调接口这个异步操作,执行完毕再将结果转发到store中</p>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> getMusic = (payload)&#123;</span><br><span class="line">  <span class="comment">//2-第一次派发的是一个函数,</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">dispath</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//3-第二次派发</span></span><br><span class="line">    fetchMusic(payload).then(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      dispatch(&#123;</span><br><span class="line">        <span class="attr">type</span>:<span class="string">&#x27;music&#x27;</span>,</span><br><span class="line">        payload</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//1-在这里第一次派发</span></span><br><span class="line">dispatch(getMusic(payload))</span><br></pre></td></tr></table></figure><h1 id="分模块"><a href="#分模块" class="headerlink" title="分模块"></a>分模块</h1><ul><li>使用 combineReducers()函数进行模块划分,接收一个对象,存放的是每个子reducers,使用是需加上每个模块名,即命名空间</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> todo <span class="keyword">from</span> <span class="string">&#x27;./todo&#x27;</span></span><br><span class="line"><span class="keyword">import</span> test <span class="keyword">from</span> <span class="string">&#x27;./test&#x27;</span></span><br><span class="line"> <span class="keyword">const</span> rootRender = combineReducers(&#123;</span><br><span class="line">   todo,</span><br><span class="line">   test</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><blockquote><p>action生成器<br>action.type </p></blockquote></font></font>]]></content>
    
    
      
      
    <summary type="html">&lt;font size=3&gt;

&lt;blockquote&gt;
&lt;font size=3 color=#5285C8&gt; 
什么时候用到 Redux ? &lt;br/&gt;&lt;/font&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;font color=black&gt;有人曾说过 :</summary>
      
    
    
    
    <category term="React" scheme="http://guestljz.com/categories/React/"/>
    
    
    <category term="Redux" scheme="http://guestljz.com/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>JS的异步机制</title>
    <link href="http://guestljz.com/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    <id>http://guestljz.com/2021/02/02/JavaScript/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/</id>
    <published>2021-02-02T00:47:57.000Z</published>
    <updated>2021-02-27T06:32:10.494Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JS的异步机制分为以下几种"><a href="#JS的异步机制分为以下几种" class="headerlink" title="JS的异步机制分为以下几种"></a>JS的异步机制分为以下几种</h3><p> 🌈 第一种是常见的回调函数的方式,但是使用这种方式有一个缺点就是 多个回调函数会造成回调地狱,上下两层函数间的代码耦合性太高,不利于代码维护<br> 🌈 第二种是 promise 对象的方式,使用promise的方式可以将嵌套的回调函数以链式方式调用,但使用这种方式有时会造成多个 then 的链式调用,可能造成语义不明确<br> 🌈 第三种是使用 generator 的方式 generator 它可以在函数的内部将函数的执行权转移出去,在函数的外部又可以将函数的执行权转移回来;所以,当我们遇到异步函数执行的时候,可以先将函数的执行权转移出去,当异步函数执行完毕后再将函数执行权转移回来;<br> 因此在generator内部对异步的操作可以用同步的顺序来书写;使用generator函数的方式,<br> 在使用generator的时候 我们需要考虑的一个问题是什么时候将函数的执行权转移回来,所以我们需要一个自动执行generator函数的机制,比如co模块等可以用来实现generator函数的自动执行<br> 🌈 第四种是 使用async函数,它是一个promise + generator 实现的一个自动执行的语法糖, 它内部自带执行器,当函数内部执行到一个await语句时,如果语句返回的是一个promise对象,那么它会等待这个promise对象的状态变成resolve后再继续向下执行,所以使用这种方式,我们也可以将异步的逻辑用同步的方式来书写,并且这个函数是自动执行的</p><p> 第一种是最常见的使用回调函数的方式,但使用这种方式有一个缺点就是,多个回调函数会造成回调地狱,上下两层函数间的代码耦合性太高,不利于代码维护</p><p> 第一种是 使用promise的方式 ,使用promise的方式它可以将嵌套的回调函数以链式的形式调用,使用这种方式,有时会造成 多个then 链式, 可能会造成代码的语义不明确</p><p> 第三中的使用generator的方式, generator函数它可以将函数的执行权转移出去,在函数的外部可以将函数的执行权转移回来,当我们遇到异步函数执行时,可以先将函数的执行权转移出去,异步函数执行完毕后,在将函数的执行权转移回来, 因此在generator内部 对异步操作可以用同步的顺序来书写,所以我们在使用generator函数的时候需要考虑一个问题,就是什么时候将函数的执行权转移回来,因此我们需要一个自动执行generator的机制,比如co模块就可以实现generator的自动执行</p><p> 第四种是async 函数,它是 promise + generator 一个自动执行的语法糖,它内部自带执行器,当函数内部执行到await语句时,如果语句返回的是一个promise对象,那么它会等待promise对象 的状态变成resolve后再继续向下执行,因此我们也可以使用async 函数来使用异步逻辑用同步的方式来书写,并且这个函数可以自动执行 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;JS的异步机制分为以下几种&quot;&gt;&lt;a href=&quot;#JS的异步机制分为以下几种&quot; class=&quot;headerlink&quot; title=&quot;JS的异步机制分为以下几种&quot;&gt;&lt;/a&gt;JS的异步机制分为以下几种&lt;/h3&gt;&lt;p&gt; 🌈 第一种是常见的回调函数的方式,但是使用这种方</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://guestljz.com/categories/JavaScript/"/>
    
    
    <category term="JS的异步机制" scheme="http://guestljz.com/tags/JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%9C%BA%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>HTML5有哪些的新特性</title>
    <link href="http://guestljz.com/2021/02/01/HTML5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <id>http://guestljz.com/2021/02/01/HTML5%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</id>
    <published>2021-02-01T13:48:02.000Z</published>
    <updated>2021-03-02T03:22:58.358Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HTML5有哪些新特特性-移除了哪些元素"><a href="#HTML5有哪些新特特性-移除了哪些元素" class="headerlink" title="HTML5有哪些新特特性,移除了哪些元素"></a>HTML5有哪些新特特性,移除了哪些元素</h1><h2 id="新增的元素"><a href="#新增的元素" class="headerlink" title="新增的元素"></a>新增的元素</h2><ol><li>绘画canvas</li><li>用于媒介回档的 video 和 audio 元素</li><li>本地离线存储 localStorage 用于长期存储数据,浏览器关闭后数据不丢失</li><li>sessionStorage 的数据在浏览器关闭后自动删除</li><li>语义化更好的内容元素,比如 article / footer / header / nav / section</li><li>表单控件,calendar / date / time / email / URL / search</li><li>新技术 webworker , websocket</li><li>新的文档属性 document.visibilityState</li></ol><h2 id="移除的元素"><a href="#移除的元素" class="headerlink" title="移除的元素"></a>移除的元素</h2><ol><li>纯表现的元素: basefont, big, center, font. s 等等</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HTML5有哪些新特特性-移除了哪些元素&quot;&gt;&lt;a href=&quot;#HTML5有哪些新特特性-移除了哪些元素&quot; class=&quot;headerlink&quot; title=&quot;HTML5有哪些新特特性,移除了哪些元素&quot;&gt;&lt;/a&gt;HTML5有哪些新特特性,移除了哪些元素&lt;/h1&gt;&lt;</summary>
      
    
    
    
    
    <category term="HTML" scheme="http://guestljz.com/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Css</title>
    <link href="http://guestljz.com/2021/01/27/Css/"/>
    <id>http://guestljz.com/2021/01/27/Css/</id>
    <published>2021-01-27T13:48:02.000Z</published>
    <updated>2021-04-29T03:10:16.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="标准的CSS-盒模型-和-低版本IE-盒模型的区别"><a href="#标准的CSS-盒模型-和-低版本IE-盒模型的区别" class="headerlink" title="标准的CSS 盒模型 和 低版本IE 盒模型的区别"></a>标准的CSS 盒模型 和 低版本IE 盒模型的区别</h2><p>👉 两种盒模型分为: W3C标准盒模型(content-box) 和 IE盒模型(border-box)<br>👉 盒模型: content(内容) padding(填充)  margin(边界)  border(边框)</p><p>💁🏼 IE盒模型和W3C标准盒模型的区别: </p><ol><li>w3c标准盒模型它的width和height 只包含 content 不包括padding 和border</li><li>IE盒模型它的width和height 包含content 和 padding 和 border,指的是content+padding+border</li></ol><p>🟣 在IE8+ 的浏览器中 我们可以通过box-sizing 改变盒模型,默认为content-box</p><h2 id="before-和-after-中的双冒号和单冒号有什么区别呢"><a href="#before-和-after-中的双冒号和单冒号有什么区别呢" class="headerlink" title="::before 和 :after 中的双冒号和单冒号有什么区别呢?"></a>::before 和 :after 中的双冒号和单冒号有什么区别呢?</h2><p>📌 单冒号(:) 用于css3伪类,双冒号(::)用于css3 伪元素(伪元素由双冒号和伪元素名称组成)</p><p>📌 双冒号是在当前规范中引入的,用于区分伪类和伪元素 伪类兼容已有的伪元素的写法,在一些浏览器中也可以使用单冒号的写法 ,新的css3中引入的伪元素则不允许单冒号的写法</p><p>🟡 伪类一般匹配的是元素的一些特殊状态,如hover / link 等,而伪元素一般匹配的特殊位置,比如 after / before等</p><h2 id="伪元素和伪类的区别"><a href="#伪元素和伪类的区别" class="headerlink" title="伪元素和伪类的区别"></a>伪元素和伪类的区别</h2><p>➜ 伪类用于当已有的元素处于某个状态时,为其添加对应的样式,这个状态时根据用户行为而动态变化的. 比如说,当用户悬停在指定的元素时,我们可以通过 :hover 来描述这个元素的状态</p><p>➜ 伪元素用于创建一些不在文档树中的元素,并为其添加样式, 它们允许我们为元素的某些部分设置样式. 比如说,我们可以通过 ::before 俩在一个元素前增加一些文本,并为这些文本添加样式. 虽然用户可以看到这些文本,但是这些文本实际上不在文档树中</p><p>🔵 总的来说: css引入伪类和伪元素概念是为了格式化文档树以外的信息. 也就是说,伪类和伪元素是用来修饰不在文档树中的部分</p><h2 id="css中哪些属性可以继承"><a href="#css中哪些属性可以继承" class="headerlink" title="css中哪些属性可以继承"></a>css中哪些属性可以继承</h2><p>🚩 每个css属性的定义中都给出了该属性默认是继承的,还是默认不继承的</p><p>1️⃣ 当一个属性默认是继承的,但没有给其默认值时: 默认继承父级元素 同属性的值<br>2️⃣ 当一个属性默认是不继承是,可以通过将它的值设置为inherit来使它从元素那获取同属性的值</p><p>🖌 有继承性的属性:</p><ol><li>字体系列属性:<br>font、font-family、font-weight、font-size、font-variant、font-stretch、font-size-adjust</li><li>文本系列属性<br>text-indent、text-align、text-shadow、line-height、word-spacing、letter-spacing、text-transform、direction、color</li><li>表格布局属性<br>caption-side、border-collapse empty-cells</li><li>列表属性<br>list-style-type、list-style-image、list-style-position、list-style</li><li>光标属性<br>cursor</li><li>元素可见性<br>visibility</li><li>不常用的：speak、page等等</li></ol><h1 id="CSS3-有哪些新特性"><a href="#CSS3-有哪些新特性" class="headerlink" title="CSS3 有哪些新特性"></a>CSS3 有哪些新特性</h1><ol><li>新增各种css选择器 nth-child(n)</li><li>圆角   (border-radius:8px)</li><li>多列布局   (multi-column layout)</li><li>阴影和反射  (Shadow / Reflect)</li><li>文字特效  (text-shadow)</li><li>线性渐变  (gradient)</li><li>旋转   (transform)</li><li>缩放,定位,倾斜,动画,多背景  transform:\scanle(0.85,0.9)\translate(0px,-30px)\skew(-9deg,0deg)\Animation:</li></ol><h1 id="渐进增强和优雅降级的定义"><a href="#渐进增强和优雅降级的定义" class="headerlink" title="渐进增强和优雅降级的定义"></a>渐进增强和优雅降级的定义</h1><ol><li>渐进增强: 针对低版本浏览器进行构建页面,保证最基本的功能,然后再针对高级浏览器进行效果 / 交互等改进和追加功能达到更好的用户体验</li><li>优雅降级: 一开始就根据高版本浏览器构建完整的功能,</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;标准的CSS-盒模型-和-低版本IE-盒模型的区别&quot;&gt;&lt;a href=&quot;#标准的CSS-盒模型-和-低版本IE-盒模型的区别&quot; class=&quot;headerlink&quot; title=&quot;标准的CSS 盒模型 和 低版本IE 盒模型的区别&quot;&gt;&lt;/a&gt;标准的CSS 盒模型 </summary>
      
    
    
    
    
    <category term="CSS" scheme="http://guestljz.com/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>如何实现一个new</title>
    <link href="http://guestljz.com/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/"/>
    <id>http://guestljz.com/2021/01/25/JavaScript/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAnew/</id>
    <published>2021-01-25T01:05:55.000Z</published>
    <updated>2021-01-27T13:14:47.071Z</updated>
    
    <content type="html"><![CDATA[<h3 id="new-一个对象的时候发生了什么"><a href="#new-一个对象的时候发生了什么" class="headerlink" title="new 一个对象的时候发生了什么"></a>new 一个对象的时候发生了什么</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name=name</span><br><span class="line">  <span class="built_in">this</span>.age=age</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> Person(<span class="string">&#x27;guestljz&#x27;</span>,<span class="number">18</span>)</span><br></pre></td></tr></table></figure><p> new一个对象的四个过程</p><ol><li>创建一个空对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let obj=&#123;&#125;</span><br></pre></td></tr></table></figure></li><li>让构造函数中的this指向新对象,并指向构造函数的函数体<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let result = Person.call(obj)</span><br></pre></td></tr></table></figure></li><li>设置新对象的__proto__属性指向构造函数的原型对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.__proto__=Person.prototype</span><br></pre></td></tr></table></figure></li><li>判断构造函数的返回值类型,如果是值类型,则返回新对象,如果是引用类型,就返回这个引用类型的对象<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(typeof(result)==&#x27;Object&#x27;)</span><br><span class="line">  p = result;</span><br><span class="line">else</span><br><span class="line">  p = obj</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;new-一个对象的时候发生了什么&quot;&gt;&lt;a href=&quot;#new-一个对象的时候发生了什么&quot; class=&quot;headerlink&quot; title=&quot;new 一个对象的时候发生了什么&quot;&gt;&lt;/a&gt;new 一个对象的时候发生了什么&lt;/h3&gt;&lt;figure class=&quot;hi</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://guestljz.com/categories/JavaScript/"/>
    
    
    <category term="javascript" scheme="http://guestljz.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>webpack</title>
    <link href="http://guestljz.com/2021/01/19/webpack/webpack/"/>
    <id>http://guestljz.com/2021/01/19/webpack/webpack/</id>
    <published>2021-01-19T02:17:17.000Z</published>
    <updated>2021-01-27T13:14:09.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何理解webpack"><a href="#如何理解webpack" class="headerlink" title="如何理解webpack"></a>如何理解webpack</h3><ol><li>是一个打包器,作用是把前端模块编译成浏览器能够识别的HTML+CSS+JS</li><li>在webpack眼中,一起皆模块</li><li>四个入门级的核心概念:入口entry / 出口output / loader / plugin</li><li>webpack可以做哪些事? 一是构建开发环境,一个上线打包</li></ol><h3 id="使用webpack"><a href="#使用webpack" class="headerlink" title="使用webpack"></a>使用webpack</h3><ul><li>npm install webpack -g   核心api包</li><li>npm install webpack -D</li><li>npm install webpack-cli -g    命令行包</li><li>npm install webpack-cli -D</li><li>执行命令 webpack  会自动读取webpack.config.js文件</li><li>默认情况,webpack会自动读取src目录下的index文件为入口文件,将dist作为出口文件</li><li>webpack –config xxx.js   手动指定配置文件</li><li>配置package.json  “build”: “webpack –config webpack.config.js”</li><li>mode 配置当前环境是生产环境还是开发环境   production  devlopment</li></ul><h1 id="适用于webpack5-15环境-随着官方文档的更新-配置内容也不一样"><a href="#适用于webpack5-15环境-随着官方文档的更新-配置内容也不一样" class="headerlink" title="适用于webpack5.15环境,随着官方文档的更新,配置内容也不一样"></a>适用于webpack5.15环境,随着官方文档的更新,配置内容也不一样</h1><h3 id="简单的使用"><a href="#简单的使用" class="headerlink" title="简单的使用"></a>简单的使用</h3><ul><li>建立文件夹 src/main.js</li><li>配置文件 webpack.config.js<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>:<span class="string">&#x27;production&#x27;</span></span><br><span class="line">  <span class="attr">entry</span>:&#123;</span><br><span class="line">   <span class="attr">app</span>: path.resolve(__dirname,<span class="string">&#x27;./src/main.js&#x27;</span>)   <span class="comment">//入口文件</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">output</span>:&#123;              <span class="comment">//出口文件</span></span><br><span class="line">    <span class="attr">filename</span>:<span class="string">&#x27;[name].[chunkhash].js&#x27;</span>   </span><br><span class="line">    <span class="attr">path</span>:path.resolve(__dirname,<span class="string">&#x27;./abc&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="构建本地服务器"><a href="#构建本地服务器" class="headerlink" title="构建本地服务器"></a>构建本地服务器</h3><ul><li>npm install webpack-dev-server -D</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer:&#123;</span><br><span class="line">  <span class="attr">port</span>:<span class="number">8078</span>,</span><br><span class="line">  <span class="attr">contentBase</span>:path.resolve(__dirname,<span class="string">&#x27;./public&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自动打开浏览器"><a href="#自动打开浏览器" class="headerlink" title="自动打开浏览器"></a>自动打开浏览器</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在package.json中的 &quot;serve&quot;:&quot;webpack --open --config webpage.config.js&quot;</span><br><span class="line">运行时 webpack serve --open</span><br><span class="line">或者在devServer中 添加open:true</span><br></pre></td></tr></table></figure><h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><ul><li><p>HTMLwebpackplugin</p></li><li><p>作用:使用它把入口文件和public中的index.html结合起来</p></li><li><p>安装</p></li><li><p>npm  install html-webpack-plugin -D</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">  <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">    <span class="attr">template</span>:path.resolve(__dirname,<span class="string">&#x27;/public/index.html&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>plugin是一个数组,参数是个选项,</p><h3 id="每次打包自动清除dist文件下的文件"><a href="#每次打包自动清除dist文件下的文件" class="headerlink" title="每次打包自动清除dist文件下的文件"></a>每次打包自动清除dist文件下的文件</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><h3 id="热更新"><a href="#热更新" class="headerlink" title="热更新"></a>热更新</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在src里面热更新</span><br><span class="line">在devServer中加上hot:true ,加上热更新</span><br><span class="line">原理:实际上是建立了一个webSocket长链接</span><br></pre></td></tr></table></figure><h3 id="Cross-env"><a href="#Cross-env" class="headerlink" title="Cross-env"></a>Cross-env</h3><p> 跨平台设置和使用环境变量的脚本(判断当前环境是生产环境还是开发环境)</p><ul><li><p>用法<br>在npm脚本中使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &#123;</span><br><span class="line">   <span class="string">&quot;scripts&quot;</span>：&#123;</span><br><span class="line">      <span class="string">&quot;build&quot;</span>：<span class="string">&quot;cross-env NODE_ENV=development webpack --config build / webpack.config.js&quot;</span> ,</span><br><span class="line">      <span class="string">&quot;serve&quot;</span>:<span class="string">&quot;ross-env NODE_ENV=production webpack serve --config webpack.config.js &quot;</span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置了一个NODE_ENV变量用于判断 当前环境<br>使用 process.env.NODE_ENV 获取<br>process.env.NODE_ENV === ‘development’</p></li><li><p>执行 npm run build  打包上线  生产环境</p></li><li><p>执行 npm run serve  本地服务   开发环境</p></li></ul><h3 id="babel-将es6-转换成es5"><a href="#babel-将es6-转换成es5" class="headerlink" title="babel 将es6 转换成es5"></a>babel 将es6 转换成es5</h3><ul><li>安装<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader -D   用于加载.js文件</span><br><span class="line">npm install @babel/core -D         babel核心库  </span><br><span class="line">npm install @babel/preset-env -D   一个具体的babel编译器  把es6转成es5</span><br></pre></td></tr></table></figure></li><li>使用 </li></ul><p>添加babel.config.json文件,给babel编译器使用的,用于更加精细地指定js编译细节<br>添加一下内容<br>preset  用于指定当前环境中所使用的js主版本/如:ts,jsx等/默认es6/<br>plugin  用于指定特殊的js语法的编译功能  配合修复主版本中的漏洞</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    [</span><br><span class="line">      <span class="string">&quot;@babel/preset-env&quot;</span>,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="string">&quot;targets&quot;</span>: &#123;</span><br><span class="line">          <span class="string">&quot;esmodules&quot;</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在module中添加一条规则<br>test: 使用正则表达式匹配是否是.js文件<br>use:使用babel-loader编译<br>exclude: /(node_modules|bower_components)/, 排除node_modules里的文件</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">  <span class="attr">rules</span>:[</span><br><span class="line">    &#123; <span class="attr">test</span>:<span class="regexp">/\.m?js$/</span>,</span><br><span class="line">      use: &#123;</span><br><span class="line">        <span class="attr">loader</span>: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">options</span>: &#123;</span><br><span class="line">          <span class="attr">presets</span>: [<span class="string">&#x27;@babel/preset-env&#x27;</span>],</span><br><span class="line">          <span class="attr">plugins</span>: [<span class="string">&#x27;@babel/plugin-proposal-object-rest-spread&#x27;</span>]  </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为babel分成许多版本,presets 中是使用哪个版本解析  plugins是修复版本的bug</p><h3 id="加载css-scss"><a href="#加载css-scss" class="headerlink" title="加载css / scss"></a>加载css / scss</h3><ul><li>安装 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">安装scss</span><br><span class="line"></span><br><span class="line">npm install sass-loader -D</span><br><span class="line">npm install sass -D     </span><br><span class="line"></span><br><span class="line">安装css-loader 和style-loader</span><br><span class="line"></span><br><span class="line">npm install --save-dev style-loader css-loader</span><br></pre></td></tr></table></figure></li><li>使用 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.s[ac]ss$/i</span>,</span><br><span class="line">        use: [</span><br><span class="line">          <span class="comment">// 将 JS 字符串生成为 style 节点</span></span><br><span class="line">          <span class="string">&quot;style-loader&quot;</span>,</span><br><span class="line">          <span class="comment">// 将 CSS 转化成 CommonJS 模块</span></span><br><span class="line">          <span class="string">&quot;css-loader&quot;</span>,</span><br><span class="line">          <span class="comment">// 将 Sass 编译成 CSS</span></span><br><span class="line">          <span class="string">&quot;sass-loader&quot;</span>,</span><br><span class="line">        ],</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">最后通过你喜欢的方式运行webpack。</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="ts-loader-转换ts"><a href="#ts-loader-转换ts" class="headerlink" title="ts-loader  转换ts"></a>ts-loader  转换ts</h3><ul><li>安装<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yarn add ts-loader --dev</span><br></pre></td></tr></table></figure></li><li>创建一个tsconfig.json文件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;sourceMap&quot;: true   //找到ts文件代码</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>匹配规则<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test:&#123;/\.ts$/,loader:&#x27;ts-loader&#x27;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="eslint的使用"><a href="#eslint的使用" class="headerlink" title="eslint的使用"></a>eslint的使用</h3><ul><li><p>安装</p></li><li><p>使用<br>配置在开发环境中<br>追加一条规则<br>config.module.rules.push({<br>test:<br>use:<br>exforce:pre<br>})<br>exforce:pre  pre表示前置执行,代表Eslint最先执行,没有错误后材质西ing之后的打包工作</p></li><li><p>配置eslint 文件<br>在根目录下添加 .eslintrc.json </p></li></ul><p>eslint检测代码三种规则</p><ul><li><p>error  违背规则报错   简写2</p></li><li><p>warn   违背规则警告      1</p></li><li><p>off    违背规则关闭</p></li><li><p>在DevServer中加上覆盖层<br>使用overlay选项</p></li></ul><h3 id="忽略eslint的检查"><a href="#忽略eslint的检查" class="headerlink" title="忽略eslint的检查"></a>忽略eslint的检查</h3><p>两种种方案</p><ol><li>修改eslint规则</li><li>使用eslint的各种注释,临时关闭<br>例如:<br>/<em>eslint-disable</em>/<br>//在这中间的代码都不检查<br>/<em>eslint-enable</em>/</li></ol><h3 id="解析路径"><a href="#解析路径" class="headerlink" title="解析路径"></a>解析路径</h3><ul><li>resolve</li></ul><p>使用resolve下的属性<br>alias:{<br> ‘@’: path.resolve(__dirname,’./src’)<br>},<br>extensions:[‘.js’,’.jsx’]  //忽略后缀,导入时可以不写.js和.jsx的后缀</p><h3 id="搭建react环境"><a href="#搭建react环境" class="headerlink" title="搭建react环境"></a>搭建react环境</h3><ul><li>安装库  React  -S  React-Dom<br>ReactDom.render(,document.getElementById(“app”))</li></ul><p>jsx react官方语法糖</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;如何理解webpack&quot;&gt;&lt;a href=&quot;#如何理解webpack&quot; class=&quot;headerlink&quot; title=&quot;如何理解webpack&quot;&gt;&lt;/a&gt;如何理解webpack&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;是一个打包器,作用是把前端模块编译成浏览器能够识别的HT</summary>
      
    
    
    
    <category term="webpack" scheme="http://guestljz.com/categories/webpack/"/>
    
    
    <category term="Webpack" scheme="http://guestljz.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>CSRF攻击</title>
    <link href="http://guestljz.com/2021/01/14/HTM-HTTP-WEB/CSRF%E6%94%BB%E5%87%BB/"/>
    <id>http://guestljz.com/2021/01/14/HTM-HTTP-WEB/CSRF%E6%94%BB%E5%87%BB/</id>
    <published>2021-01-14T00:56:17.000Z</published>
    <updated>2021-02-27T03:13:28.919Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是CSRF攻击"><a href="#什么是CSRF攻击" class="headerlink" title="什么是CSRF攻击"></a>什么是CSRF攻击</h1><p>🍢  CSRF攻击指的是跨站请求伪造攻击,攻击者诱导用户进入一个第三方网站,然后网站向被攻击网站发送跨站请求,如果用户在被攻击网站中保存了登录状态,那么攻击者就可以利用这个登录状态,绕过后台的用户验证,冒充用户向服务器执行一些操作</p><p>🍢 CSRF攻击的本质是利用了cookie会在同源请求中携带发送给服务器的特点,以此来实现用户的冒充</p><h1 id="CSRF攻击的分类"><a href="#CSRF攻击的分类" class="headerlink" title="CSRF攻击的分类"></a>CSRF攻击的分类</h1><p>  一般的CSRF攻击类型有三种:</p><p>🍭 第一种是GET类型的CSRF攻击,比如在网站中的一个 img 标签里构建一个请求,当用户打开这个网站的时候就会自动发起提交</p><p>🍭 第二种是POST类型的CSRF攻击,比如说构建一个报单,然后隐藏它,当用户进入页面时,自动提交这个表单</p><p>🍭 第三种是链接类型的CSRF 攻击,比如说在a标签的href属性里构建一个请求,然后诱导用的去点击</p><h1 id="如何防护CSRF-攻击"><a href="#如何防护CSRF-攻击" class="headerlink" title="如何防护CSRF 攻击"></a>如何防护CSRF 攻击</h1><p>  CSRF攻击中,重要的一环就是cookie,这一份cookie模拟了用户的身份,所以防范CSRF攻击cookie是一个入手点,恰巧,cookie中有个字段,可以对请求中cookie的携带做一些限制</p><h2 id="第一种方法从-samSite-入手"><a href="#第一种方法从-samSite-入手" class="headerlink" title="第一种方法从 samSite 入手"></a>第一种方法从 samSite 入手</h2><p>  <strong>samSite</strong> ,可设为3个值: <strong>Strict / Lax / None</strong></p><p>🍧 Strict 模式: 浏览器完全禁止第三方请求携带cookie,比如当你访问 <code>https://guestljz.gitee.io/</code> 这个网站,那么你只能在访问 <code>https://guestljz.gitee.io/</code> 这个网站中携带cookie,其他网站都不能携带<br>🍨 Lax 模式: 相对松一点,只能在 get 方法请求表单或者a标签中发送请求时 携带cookie,其他情况不能<br>🍦 None 模式: 默认情况, 任何请求都会携带cookie</p><h2 id="第二种方法-验证站点来源"><a href="#第二种方法-验证站点来源" class="headerlink" title="第二种方法 验证站点来源"></a>第二种方法 验证站点来源</h2><p> 利用请求头中的 <strong>Origin</strong>和<strong>Refer</strong><br> Origin 中包含了域名信息, Refer中包含的详细的URL路径,以此来验证<br> 当然了,这些都可以伪造,通过AJAX中自定义请求</p><h2 id="第三种方法-CSRF-Token"><a href="#第三种方法-CSRF-Token" class="headerlink" title="第三种方法 CSRF Token"></a>第三种方法 CSRF Token</h2><p>首先,浏览器向服务器发送请求时,服务器生成一个字符串,将其植入到返回的页面中<br>然后浏览器如果要发生请求,就必须带上这个字符串,然后服务器来验证是否合法,如果不合法则不响应.<br>这个字符串就是CSRF Token 第三方网站无法拿到这个token,因此也就被服务器拒绝</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;什么是CSRF攻击&quot;&gt;&lt;a href=&quot;#什么是CSRF攻击&quot; class=&quot;headerlink&quot; title=&quot;什么是CSRF攻击&quot;&gt;&lt;/a&gt;什么是CSRF攻击&lt;/h1&gt;&lt;p&gt;🍢  CSRF攻击指的是跨站请求伪造攻击,攻击者诱导用户进入一个第三方网站,然后网</summary>
      
    
    
    
    <category term="HTTP" scheme="http://guestljz.com/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="http://guestljz.com/tags/HTTP/"/>
    
  </entry>
  
  <entry>
    <title>强缓存_协商缓存</title>
    <link href="http://guestljz.com/2021/01/05/HTM-HTTP-WEB/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://guestljz.com/2021/01/05/HTM-HTTP-WEB/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2021-01-05T00:43:25.000Z</published>
    <updated>2021-02-27T02:17:33.293Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器的缓存机制"><a href="#浏览器的缓存机制" class="headerlink" title="浏览器的缓存机制"></a>浏览器的缓存机制</h1><ol><li>首先通过 cache-control验证强缓存是否可用,如果可用直接只用</li><li>否则,进入协商缓存,即发送HTTP请求,服务器通过浏览器请求头中的相应字段来验证协商缓存是否可用,如果可用直接使用,否则,返回新的资源和200状态码</li></ol><blockquote><p>浏览器的缓存分为两种,一种是发送HTTP请求,一种是不发送请求</p></blockquote><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><ul><li><p> 强缓存(本地缓存),它不需要发送HTTP请求 ,如果命中缓存,浏览器直接从缓存中读取资源</p></li><li><p> 在HTTP/1.0 中检查强缓存的字段是expires, 在HTTP/1.1 中检查强缓存的字段是cache-control </p></li></ul><ol><li>EXpires<br>expires 即过期时间  存在服务端返回的响应头中,告诉浏览器在这个过期时间之前可以直接读取缓存,不需要再次请求<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires: Wed, <span class="number">22</span> Nov <span class="number">2020</span> <span class="number">10</span>:<span class="number">41</span>:<span class="number">00</span> GMT</span><br></pre></td></tr></table></figure><blockquote><p>表示资源在2020年11月22号10点41分过期,过期了就必须重新发送请求<br>但~,这个方法有个小bug,那就是服务端的时间和浏览器的时间也许并不是一致<br>所以服务器返回的过期时间可能就是不准确的,所以这种方式在HTTP1.1版本中就被抛弃了</p></blockquote></li></ol><ol start="2"><li>Cache-Control<br>在HTTP1.1中采用 cache-control 字段,它和expires的区别是:expires采用的是具体的时间点来控制缓存,而cache-control采用的是时间时长来控制缓存</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">max-age=<span class="number">6000</span></span><br></pre></td></tr></table></figure><blockquote><p>表示 这个响应在返回后的7600秒,也就是两个小时后过期,在这两个小时内可以直接使用缓存</p></blockquote><ol start="3"><li>cache-control除了max-age这个属性还有其他一些属性</li></ol><ul><li>public: 客户端和代理服务端都可以缓存,因为一个请求可能要经过不同的代理服务器才能到达目标服务器,那么结果不仅是在浏览器可以缓存,中间的任何代理节点都可以缓存</li><li>private: 只能浏览器缓存,中间代理不能缓存</li><li>no-cache: 跳过当前缓存,发送http请求,即进入协商缓存</li><li>no-store: 不以任何形式进行缓存</li><li>s-maxage: 和max-age相似,区别在于s-maxage是针对代理服务器的缓存时间</li></ul><blockquote><p> 如果expires和cache-control同时存在的时候,cache-control会被优先考虑<br>那么,当资源缓存时间超时了,也就是强缓存失效了,那该怎么办?       答案是:进入协商缓存 </p></blockquote><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><ul><li><p>强缓存失效后,浏览器在请求头中携带相应的 缓存tag 来向服务器发请求,由服务器来根据这个tag,决定是否使用缓存</p><blockquote><p>缓存tag有两种</p></blockquote></li></ul><ol><li><p>last-modified,即最后修改时间<br>浏览器第一次向服务器发送请求时,服务器接收到后会在响应头中携带一个last-modified字段返回<br>浏览器接收到后,如果再次请求,会在请求头中携带一个if-modified-since的字段的值就是服务器返回last-modified字段的值(就是最后修改时间),服务器接收到后,会将两个值进行对比,<br>如果浏览器请求头中的值小于最后修改时间,表示该资源需要更新,即像正常的http请求一样返回资源<br>否则返回304,告诉浏览器直接使用缓存</p></li><li><p>etag<br>etag是服务器给文件生成的一个唯一标识,只要这个文件内容有改动,就会生成一个新的标识符,服务器就会通过响应头将这个值传给浏览器<br>浏览器接收到etag值后,会在下一次请求中,将etag的值,作为if-none-macth这个字段的值放在请求头中传给服务器,服务器接收到后,会将两个值进行对比<br>如果浏览器请求头中的值和服务器中的etag不同,表示需要返回新的资源了,<br>否则返回304,告诉浏览器直接使用缓存</p></li></ol><blockquote><p>总结:</p><p>浏览器的缓存机制,首先先通过cache-control验证强缓存是否可用,如果可以用,则直接使用强缓存,否则进入协商缓存,即发送http请求,服务器通过请求头中的if-none-match和if-modified-since字段检查资源更新,如果请求头中这个两个字段的值如果if-none-match的值跟服务器中的etag不一样或if-modifed-since的值小于服务器中last-modified,表示资源需要更新,返回新的资源,否则返回304,告诉浏览器直接使用缓存</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;浏览器的缓存机制&quot;&gt;&lt;a href=&quot;#浏览器的缓存机制&quot; class=&quot;headerlink&quot; title=&quot;浏览器的缓存机制&quot;&gt;&lt;/a&gt;浏览器的缓存机制&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;首先通过 cache-control验证强缓存是否可用,如果可用直接只用&lt;/li</summary>
      
    
    
    
    <category term="HTTP" scheme="http://guestljz.com/categories/HTTP/"/>
    
    
    <category term="HTTP" scheme="http://guestljz.com/tags/HTTP/"/>
    
  </entry>
  
</feed>
